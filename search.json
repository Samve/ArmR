[
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Ներածություն",
    "section": "",
    "text": "1.1 Կիրառելիությունը\nլեզուն հատուկ նպատակ ունեցող ծրագրավորման լեզու է. այն նախատեսված է տվյալների հետ աշխատելու համար: Այն միակ նմանատիպ լեզուն չէ. այլ օրինակներից են Python և SAS software (Copyright © [2025] SAS Institute Inc.) լեզուները: Տվյալների վերլուծության ոչ բոլոր խնդիրների համար է այն լավագույն ընտրությունը։ Օրինակ, բավականաչափ հարմար է գծագրեր գծելիս, տվյալներ մշակելիս և վիճակագրական մոդելներ կառուցելիս, դժվարությունների առաջ կարող է կանգնել, օրինակ, համակարգչի օպերատիվ հիշողությունում չտեղավորվող տվյալների հետ աշխատելիս։ Այդ պատճառով հաճախ այն օգտագործվում է այլ ծրագրերի հետ համատեղ, ինչպես, օրինակ, մեծ տվյալների հետ աշխատելիս կարող են օգտագործվել տվյալների բազաների կառավարման համակարգեր, ինչպիսինն են MySQL, PostgreSQL, SQLite կամ Oracle-ը։",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Ներածություն</span>"
    ]
  },
  {
    "objectID": "intro.html#ստեղծման-պատմությունը-և-հիմնական-հատկությունները",
    "href": "intro.html#ստեղծման-պատմությունը-և-հիմնական-հատկությունները",
    "title": "1  Ներածություն",
    "section": "1.2 Ստեղծման պատմությունը և հիմնական հատկությունները",
    "text": "1.2 Ստեղծման պատմությունը և հիմնական հատկությունները\n ծրագրավորման լեզուն ծագել է S ծրագրավորման լեզվից, այդ պատճառով համարվում է վերջինիս բարբառ: S ստեղծվել է 1976թ․-ին՝ Ջոն Չեմբերսի (John Chambers) կողմից և սկզբնական շրջանում հանդիսանում էր Fortran լեզվի գրադարանների հավաքածու։ 1988թ․-ին այն ամբողջովին վերափոխվում է և գրվում C լեզվով ու ստանում ժամանակակից տեսք։ Սա լեզվի երրորդ թողարկումն էր (S3): 1998-ին թողարկվում է լեզվի չորրորդ տարբերակը։\n-ը ստեղծվել է Նոր Զելանդիայում 1991թ․-ին՝ Ռոսս Իհակայի և Ռոբերտ Ջենթլմենի կողմից (Ross Ihaka and Robert Gentlement)(Ihaka and Gentleman 1996)։ 2000-ին լույս է տեսնում լեզվի 1.0.0 թողարկումը, իսկ 2020-ին՝ 4.0.0 թողարկումը։\n լեզուն ազատ օգտագործման իրավունքով է տարածվում (open source software): Սա նշանակում է, որ այն անվճար է տարածվում նաև տեղի ունեն հետևյալ պայմանները՝\n\nծրագիրն օգտագործելու ազատություն՝ անկախ նպատակից,\nազատություն ուսումնասիրելու, թե ինչպես է ծրագիրն աշխատում։ Սրա նախապայման է հանդիսանում ծրագրերի ներքին կառուցվածքին հասանելիությունը,\nյուրաքանչյուր ոք իրավունք ունի այն տարածելու իր հայեցողությամբ,\nազատություն բարելավելու ծրագիրը և ազատ տարածելու բարելավումները։\n\n լեզուն «երկխոսող» (interactive) է՝ այն կարող է ստանալ հարցն ու միանգամից դրան պատասխանել, այնուհետև լսել նոր հարց։ Անգամ ծրագիրը, որը բաղկացած է մի քանի տողերից՝ կարդացվում է տող առ տող։ Այս պատճառով -ն ունի աշխատելու երկու վիճակ՝ երկխոսության վիճակ, երբ հրամանները կատարվում են տող առ տող ներմուծելիս` տողային հրամանների համար նախատեսված պատուհանում, (console mode) կամ տեքստային պատուհանում գրելով մի քանի տողից բաղկացած ծրագիր և այն ամբողջությամբ ներմուծելիս (հիշենք, որ նույնիսկ այս դեպքում ծրագիրը կարդացվում է տող առ տող։) Այս վերջինը կոչվում է՝ script mode:",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Ներածություն</span>"
    ]
  },
  {
    "objectID": "intro.html#թողարկումները",
    "href": "intro.html#թողարկումները",
    "title": "1  Ներածություն",
    "section": "1.3 Թողարկումները",
    "text": "1.3 Թողարկումները\n լեզուն ունենում է նոր թողարկումներ տարեկան մոտավորապես երկու անգամ։ Նոր թողարկումների ժամանակ ավելացվում են լեզվի նոր գործառույթներ, շտկվում առկա թերությունները, երբեմն նաև կատարվում են հին գործառույթների փոփոխություններ։ Հետևաբար կարևոր է ծրագիր գրելիս նշել այն թողարկման համարը, որով այն գրված է։ Երբեմն նոր թողարկումներով հին ծրագիրն աշխատեցնելիս կարող են ի հայտ գալ անսպասելի արդյունքներ, կամ պարզապես սխալ տեղի ունենա։ Նշվածը վերաբերվում է նաև ծրագրում օգտագործված բոլոր գրադարաններին։ Այդ պատճառով այս դասախոսությունում մենք միշտ կնշենք լեզվի և գրադարանների թողարկման համարները, որոնք օգտագործվել են դասախոսությունում առկա ծրագրերը գրելիս։ Ստորև բերված է -ի թողարկումը և դրա մականունը (nickname, սովորաբար ամեն թողարկում իր մականունն ունի)։\n\n\n[1] \"R version 4.5.2 (2025-10-31 ucrt)\"\n\n\n[1] \"[Not] Part in a Rumble\"\n\n\nՍտերև բերված է -ի հիմնական թողարկումների համառոտ պատմությունը՝ կարճ նկարագրություններով։\n\nԹողարկում 1.0.0: (Փետրվարի 29, 2000 թ․) Առաջին հիմնական թողարկումը։\nԹողարկում 2.0.0: (Հոկտեմբեր 4, 2000 թ․) Հիմնական գրադարանների բաժանում նոր datasets գրադարանի ստեղծում և grDevices գրադարանի բաժանում graphics գրադարանից։ grDevices պարունակում է գծագրեր որոնք ընդահանուր են base և grid գծագրերի համար։",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Ներածություն</span>"
    ]
  },
  {
    "objectID": "intro.html#ամփոփում",
    "href": "intro.html#ամփոփում",
    "title": "1  Ներածություն",
    "section": "1.5 Ամփոփում",
    "text": "1.5 Ամփոփում\n\nCRAN\nCode (տեքստային ծրագիր)\nOpen source software\nBase Packages\nInteractive programming\nConsole mode\nScript mode\n version, nickname\n\n\n\n\n\nIhaka, Ross, and Robert Gentleman. 1996. “R: A Language for Data Analysis and Graphics.” Journal of Computational and Graphical Statistics 5 (3): 299–314.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Ներածություն</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Գրականություն",
    "section": "",
    "text": "Cleveland, William S. 2001. “Data Science: An Action Plan for\nExpanding the Technical Areas of the Field of Statistics.”\nInternational Statistical Review 69 (1): 21–26.\n\n\nDonoho, David. 2017. “50 Years of Data Science.”\nJournal of Computational and Graphical Statistics 26 (4):\n745–66.\n\n\nIhaka, Ross, and Robert Gentleman. 1996. “R: A Language for Data\nAnalysis and Graphics.” Journal of Computational and\nGraphical Statistics 5 (3): 299–314.\n\n\nR Core Team. 2025. R: A Language and Environment for Statistical\nComputing. Vienna, Austria: R Foundation for Statistical Computing.\nhttps://www.R-project.org/.\n\n\nTukey, John W. 1962. “The Future of Data Analysis.” In\nBreakthroughs in Statistics: Methodology and Distribution,\n408–52. Springer.\n\n\nWickham, Hadley. 2011. “The Split-Apply-Combine Strategy for Data\nAnalysis.” Journal of Statistical Software 40 (1): 1–29.\nhttps://www.jstatsoft.org/v40/i01/.",
    "crumbs": [
      "Գրականություն"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R ծրագրավորում",
    "section": "",
    "text": "Մասին\n ծրագրավորման (R Core Team 2025) դասախոսություններ՝ սկզբանական ուսուցման նպատակով։ Գրքի տարբերակ՝ 1.2.4: Այս տարբերակում դեռ կիսատ է Կիրառական Վիճակագրություն գլուխը:\nԳրքում օգտագործված է -ի հետևյալ տարբերակը՝\n\n\n[1] \"R version 4.5.2 (2025-10-31 ucrt)\"\n\n\nԹեև -ի տասնյակ հազարավոր գրադարաններ են առկա, այս դասախոսությունը նվիրված է ծրագրավորման հիմնական միջավայրին։\nԳիրքը ստեղծված է Quarto ծրագրով։ Ծրագրի մասին ավելին իմանալու համար կարող եք այցելել հետևյալ կայքը՝ https://quarto.org/docs/books:\n\n\n\n\nR Core Team. 2025. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing. https://www.R-project.org/.",
    "crumbs": [
      "Մասին"
    ]
  },
  {
    "objectID": "rintro.html",
    "href": "rintro.html",
    "title": "2  R ծրագրավորման միջավայր",
    "section": "",
    "text": "2.1 Լեզվի շարահյուսությունը (Syntax)\nԾրագիրը բաղկացած է հրամաններից, որոնք, ինչպես նշեցինք վերևում, կարդացվում են տող առ տող, իսկ մեկ տողի վրա հնարավոր է մի քանի հրամաններ գրել՝ բաժանելով դրանք ; նշանով։ Հետևյալ նշանը հանդիսանում է մեկնաբանությունների նշան և դրանից ձախ գրված ամեն ինչ, այդ թվում նշանն ինքը, հանդիսանում է մեկնաբանություն և անտեսվում է ծրագրի կողմից՝\n# Comments that are ignored\n1 + 6\n\n[1] 7\nՀրամանները պետք է շարահյուսորեն ճիշտ լինեն կազմված որպեսզի կարողանան կատարվել ծրագրի կողմից։ Օրինակ հետևյալ հրամանը շարահյուսորեն թերի է և չի կատարվի ծրագրի կողմից\n6 +\nԵրբ ներմուծվում է թերի հրաման, ապա տողային հրամանների համար նախատեսված պատուհանում (console mode) ծրագիրը պատրաստ է հրամանների կատարման նշանը &gt; փոխարինվում է սպասողական նշանով՝ +, որի դեպքում կա՛մ պետք է լրացնել հրամանը, որ այն թերի չլինի, կա՛մ էլ սեղմել ելքի ստեղնը՝ Esc:\nՎերևում նկարագրված թվաբանական գործողությունը ներմուծելիս մենք իրականում ծրագրին տալիս ենք երկու գործողություններ՝ կատարման համար, նախ կատարել թվաբանական գործողությունը, ապա այն տպել։ Սա կոչվում է ինքնաբերաբար տպում (auto-printing), երբ մենք բացահայտ չենք կանչում print() ֆունկցիան՝\nprint(6 + 1)\n\n[1] 7\n- ում մեծատառերը և փոքրատառերը տարբերակվում են (case sensitive), այդ պատճառով անուններում գոնե մեկ տառը մեծատառով գրելու դեպքում այն դառնում է լրիվ այլ անուն։",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R ծրագրավորման միջավայր</span>"
    ]
  },
  {
    "objectID": "rintro.html#լեզվի-շարահյուսությունը-syntax",
    "href": "rintro.html#լեզվի-շարահյուսությունը-syntax",
    "title": "2  R ծրագրավորման միջավայր",
    "section": "",
    "text": "2.1.1 Թվաբանական գործողությունները\n-ում առկա են հետևյալ թվաբանական գործողությունները՝\n\n4 - 6\n\n[1] -2\n\n4 + 6\n\n[1] 10\n\n2 * 3\n\n[1] 6\n\n2 / 3\n\n[1] 0.6666667\n\n2^3\n\n[1] 8\n\n3 %% 2\n\n[1] 1\n\n3 %/% 2\n\n[1] 1\n\n\nԳործողությունների առաջնահերթությունը (operator precedence, operator priority) հետևյալն է՝ նախ կատարվում է աստիճանի բարձրացման գործողությունը, ապա բազմապատկում, բաժանում, մնացորդի գտնում, կամ առանց մնացորդի բաժանումը գործողությունը, իսկ վերջում՝ գումարում կամ հանումը։\n\n3+10*2\n\n[1] 23\n\n3*2^2\n\n[1] 12\n\n5%%2*3\n\n[1] 3\n\n\nՀավասարազոր գործողությունների կատարման հերթականությունը որոշվում է ձախից աջ։ Օրինակ,\n\n10/5/2\n\n[1] 1\n\n\nԻհարկե հնարավոր է փոխել գործողությունների կատարման առաջնահերթությունը՝ օգտագործելով փակագծեր։\n\n(2+3)^2\n\n[1] 25\n\n\n\n\n2.1.2 Վերագրում\nՎերագրման գործողությունը կատարվում է &lt;- նշանի միջոցով, որը սլաք է և ցույց է տալիս վերագրման ուղղությունը՝ աջից ձախ։ Այլ ծրագրավորման լեզուներում վերագրում կատարվում է հավասարության նշանի (=) միջոցով։ Հավասարության նշանը  լեզվում նույնպես առկա է, բայց մի քիչ այլ գործառույթ ունի։ Հաճախ գրքերում կարելի է տեսնել, որ վերագրում կատարված է հավասարության նշանի միջոցով և իրականում եթե ձեր ծրագրում օգտագործեք հավասարության նշանը, ապա դեպքերի գերակշիռ մեծամասնությունում որևէ խնդրի չեք հանդիպի։ Բայց սլաքի և հավասարության նշանի միջև կա տարբերություն և մենք հետագայում օրինակների վրա կհամոզվենք։ Առայժմ միայն նկատենք, որ ի տարբերություն հավասարություն նշանի՝ սլաքը թույլ է տալիս նաև վերագրում իրականացնել նաև ձախից աջ՝\n\nx &lt;- 5\nx\n\n[1] 5\n\n6 -&gt; x\nx #print(x)\n\n[1] 6\n\n\nԱյստեղ նույնպես տեղի ունի ինքնաբերաբար տպումը, երբ մենք ներմուծում ենք միայն փոփոխականի անունը։\n\n\n2.1.3 Փոփոխականներ\nՓոփոխական ստեղծելիս նրա տեսակը նախապես չի հայտարարվում։ Վերագրման գործողությունը կատարելիս ծրագիրն ինքը կարող է կռահել փոփոխականի տեսակը։ Այս պատճառով հնարավոր է անգամ գոյություն ունեցող փոփոխականին վերագրել այլ տեսակի արժեք, այդ դեպքում հին արժեքն իր տեսակով կջնջվի և փոփոխականում կպահվի նոր արժեքն իր տեսակով։ Փոփոխականին հնարավոր է վերագրել ցանկացած օբյեկտ, օրինակ, ֆունկցիա (տե՛ս հաջորդ ենթաբաժնում։)\n-ում կան սահմանափակումներ փոփոխականի անուններ ընտրելիս։ Փոփոխականի անունը կարող է պարունակել թվեր, տառեր, կետ կամ ստորին գծիկ՝ “_”։ Անունը կարող է սկսվել միայն տառով կամ կետով (այս դեպքում հաջորդը չի կարող թիվ լինել), բացի այդ, ինչպես նշվեց, -ը տարբերակում է մեծատառերը և փոքրատառերը, հետևաբար պետք է ուշադիր լինել անուն ընտրելիս։\n\n\n2.1.4 Ֆունկցիաներ\n-ում ֆունկցիաները կատարում են նույն գործառույթը ինչ մաթեմատիկայում՝ նրանք ստեղծում են համապատասխանություն օբյեկտների միջև։\nՎերցնելով որոշ օբյեկտ, ֆունկցիան կատարում է գործողություններ դրա հետ ու վերադարձնում այլ օբյեկտ։ Սկզբնական օբյեկտը կոչվում է ֆունկցիայի արգումենտ։ -ը պարունակում է բազմաթիվ նախասահմանված ֆունկցիաներ (built-in functions), որոնք նախատեսված են տարբեր տեսակ խնդիրներ լուծելու համար։ Նախասահմանված ֆունկցիաների ամենապարզ օրինակ են հանդիսանում թվաբանական գործողությունները և վերագրումը՝\n\n`&lt;-`(u, 2018)\nu\n\n[1] 2018\n\n5 + 19\n\n[1] 24\n\n`+`(5, 19)\n\n[1] 24\n\n\nՄաթեմատիկական գործողությունների համար ևս կան նախասահմանված ֆունկցիաներ՝\n\nsqrt(16)\n\n[1] 4\n\nabs(-5)\n\n[1] 5\n\n\nՔանի որ ամեն ինչ օբյեկտ է, ապա հնարավոր է փոփոխականին վերագրել անգամ ֆունկցիաներ՝\n\nx &lt;- `+`\nx(12, 34)\n\n[1] 46\n\n\n -ում նախասահմանված ֆունկցիաներ կան, որոնք կարող են տեղեկատվություն տրամադրել օգտագործողի կողմից սահմանված փոփոխականների վերաբերյալ՝\n\nls()\n\n[1] \"u\" \"x\"\n\n\nԻնչպես նաև, հնարավորություն ընձեռել ջնջելու սահմանված փոփոխականներից մեկը կամ մի քանիսը, ինչպես նաև բոլորը՝\n\nrm(x)\nls()\n\n[1] \"u\"\n\nx &lt;- 10; y &lt;- 12; z &lt;- 13; u &lt;- 54\nls()\n\n[1] \"u\" \"x\" \"y\" \"z\"\n\nrm(x, y)\nls()\n\n[1] \"u\" \"z\"\n\n\nԳոյություն ունեն ծրագրավորման որոշակի կանոններ, որոնց օգտագործումը թույլ կտա խուսափել բազմաթիվ հնարավոր սխալներից (Good Programming Practice): Այդ սկզբունքներից է՝ ամեն նոր ծրագրավորման խնդիր լուծելիս ջնջել բոլոր ստեղծված օբյեկտները, որոնք մնացել էին նախորդ ծրագիրն իրականացնելիս։ Դա կարող է կատարվել հետևյալ ձևով՝\n\nrm(list = ls())\nls()\n\ncharacter(0)\n\n\nԿան նաև բազմաթիվ նախասահմանված ֆունկցիաներ որոնք տեղեկություններ են տրամադրում թողարկման մասին, ինչպես օրինակ\n\nsessionInfo()\n\nR version 4.5.2 (2025-10-31 ucrt)\nPlatform: x86_64-w64-mingw32/x64\nRunning under: Windows 11 x64 (build 26100)\n\nMatrix products: default\n  LAPACK version 3.12.1\n\nlocale:\n[1] LC_COLLATE=English_United States.utf8 \n[2] LC_CTYPE=English_United States.utf8   \n[3] LC_MONETARY=English_United States.utf8\n[4] LC_NUMERIC=C                          \n[5] LC_TIME=English_United States.utf8    \n\ntime zone: America/New_York\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] htmlwidgets_1.6.4 compiler_4.5.2    fastmap_1.2.0     cli_3.6.5        \n [5] tools_4.5.2       htmltools_0.5.9   otel_0.2.0        rstudioapi_0.17.1\n [9] rmarkdown_2.30    knitr_1.51        jsonlite_2.0.0    xfun_0.55        \n[13] digest_0.6.39     rlang_1.1.6       evaluate_1.0.5   \n\n\n-ում նախասահմանված բոլոր ֆունկցիաները խմբավորված են նախասահմանված հիմնական գրադարաններից որևէ մեկում (base packages), որոնք յոթն են և միշտ ակտիվացված են (attached packages)։\n\n\n2.1.5 Ակտիվացնել գրադարաններ\n-ում գրադարան ակտիվացնելու համար կարող են օգտագործվել հետևյալ ֆունկցիաները, որոնք որպես արժեք ընդունում են ակտիվացվող գրադարանի անունը, որը նախապես պետք է տեղադրված լինի։ Ստորև ներկայացված են տեղադրման և ակտիվացման ֆունկցիաները՝ HistData գրադարանի համար։\n\n#install.packages(\"HistData\")\nlibrary(HistData) #or\nrequire(HistData)\n\nԱյս երկու ֆունկցիաների տարբերությունն է, որ require() ֆունկցիան նաև տրամաբանական արժեք է վերադարձնում՝ գրադարանն ակտիվացնելուց հետո։\nls() ֆունցկիան կարող է նորից կանչվել՝ պարզելու համար ակտիվացված գրադարանի պարունակությունը։\n\nls(\"package:HistData\")\n\n [1] \"Arbuthnot\"         \"Armada\"            \"Bowley\"           \n [4] \"Breslau\"           \"Cavendish\"         \"ChestSizes\"       \n [7] \"ChestStigler\"      \"Cholera\"           \"CholeraDeaths1849\"\n[10] \"CushnyPeebles\"     \"CushnyPeeblesN\"    \"Dactyl\"           \n[13] \"DrinksWages\"       \"EdgeworthDeaths\"   \"Fingerprints\"     \n[16] \"Galton\"            \"GaltonFamilies\"    \"Guerry\"           \n[19] \"HalleyLifeTable\"   \"Jevons\"            \"Langren.all\"      \n[22] \"Langren1644\"       \"Macdonell\"         \"MacdonellDF\"      \n[25] \"Mayer\"             \"Michelson\"         \"MichelsonSets\"    \n[28] \"Minard.cities\"     \"Minard.temp\"       \"Minard.troops\"    \n[31] \"Nightingale\"       \"OldMaps\"           \"PearsonLee\"       \n[34] \"Playfair1824\"      \"PolioTrials\"       \"Pollen\"           \n[37] \"Prostitutes\"       \"Pyx\"               \"Quarrels\"         \n[40] \"Saturn\"            \"Sdeaths\"           \"Sdensity\"         \n[43] \"Snow.dates\"        \"Snow.deaths\"       \"Snow.deaths2\"     \n[46] \"Snow.polygons\"     \"Snow.pumps\"        \"Snow.streets\"     \n[49] \"SnowMap\"           \"Splot\"             \"Spolygons\"        \n[52] \"Spumps\"            \"Sscale\"            \"Sstreets\"         \n[55] \"Virginis\"          \"Virginis.interp\"   \"Wheat\"            \n[58] \"Wheat.monarchs\"    \"Yeast\"             \"YeastD.mat\"       \n[61] \"ZeaMays\"          \n\n\nՄինչդեռ packageVersion() ֆունկցիան հնարավորություն է տալիս պարզելու գրադարանի թողարկումը, իսկ packageDate() թողարկման տարեթիվը։\n\npackageVersion(\"HistData\")\n\n[1] '1.0.0'\n\npackageDate(\"HistData\")\n\n[1] \"2025-11-25\"\n\n\nԳրադարանը հնարավոր է նաև ապաակտիվացնել։\n\ndetach(\"package:HistData\")\n\n\n\n2.1.6 Ամփոփում\n\nAssignment\nSyntax\nBuilt-in functions\nAuto-printing\nCase sensitive\nAttached/detach packages\nBase packages\nGood Programming Practice\n\nFunctions\n\nbase::print()\nbase::sqrt()\nbase::abs()\nbase::ls()\nbase::rm()\nutils::sessionInfo()\nutils::install.packages()\nbase::library()\nbase::require()\nbase::detach()\nutils::packageVersion()\nutils::packageDate()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R ծրագրավորման միջավայր</span>"
    ]
  },
  {
    "objectID": "rintro.html#data",
    "href": "rintro.html#data",
    "title": "2  R ծրագրավորման միջավայր",
    "section": "2.2 Տվյալների տեսակները և տվյալային կառուցվածքներ",
    "text": "2.2 Տվյալների տեսակները և տվյալային կառուցվածքներ\n\n2.2.1 Տվյալների տեսակները (Data Types)\n-ում կան տվյալների պահպանման 5 տեսակներ՝\n\ncharacter - տեքստային\nnumeric (real numbers) - թվային (իրական թվեր)\ninteger - ամբողջ թվեր\ncomplex - կոմպլեքս թվեր\nlogical (True/False) - տրամաբանական՝ այո, ոչ\n\n - ում, ի տարբերություն շատ ծրագրավորման լեզուների, փոփոխականը ստեղծելիս նրա տեսակը չի հայտարարվում։ Փոփոխական հնարավոր է ստեղծել նրան արժեք վերագրելով և ծրագիրն ինքը, հիմք ընդունելով արժեքը, կստեղծի փոփոխականի տեսակը։ Նախասահմանված class() ֆունկցիան վերադարձնում է փոփոխականի տեսակը։\n\nx &lt;- \"Name\"\nclass(x)\n\n[1] \"character\"\n\nx &lt;- 1\nclass(x)\n\n[1] \"numeric\"\n\nx &lt;- 1L\nclass(x)\n\n[1] \"integer\"\n\nx &lt;- TRUE\nclass(x)\n\n[1] \"logical\"\n\nx &lt;- 3+1i\nclass(x)\n\n[1] \"complex\"\n\n\nՆկատենք, որ բոլոր իրական թվերը, այդ թվում ամբողջ թվերը ծրագրի կողմից հասկացվում են որպես numeric տեսակի, այսինքն՝ տասնորդական ճշտության իրական թվեր։ Որպեսզի ծրագիր ներմուծված թիվը հասկանա որպես ամբողջ թիվ՝ վերջում պետք է ավելացնել L տառը։\n - ում կա նաև հատուկ թիվ, որով նշանակվում են շատ մեծ թվերը և որը կատարում է մաթեմատիկայի անվերջության դերը։ Այն նշանակվում է Inf։\n\n2^1024\n\n[1] Inf\n\n1/0\n\n[1] Inf\n\nInf+5\n\n[1] Inf\n\nInf*(-3)\n\n[1] -Inf\n\n\nՀիշենք, որ -ը տարբերակում է մեծատառերը և փոքրատառերը, հետևաբար ուշադրություն դարձնենք, որ Inf հատուկ անունը սկսվում է մեծատառով։\n-ում կա նաև NaN հատուկ արժեքը, որը ցույց է տալիս չսահմանված գործողությունների արդյունքում ստացված արժեքները NaN:\n\n0/0\n\n[1] NaN\n\n\nՏրամաբանական արժեքները մեծամասամբ ստացվում են տրամաբանական գործողությունների արդյունքում՝ համեմատում, ժխտում, և, կամ։\n\nx &lt;- 3 &lt; 4\nx\n\n[1] TRUE\n\nx &lt;- 4 &lt;= 4\n!x\n\n[1] FALSE\n\nx == TRUE\n\n[1] TRUE\n\nx & 3 &lt; 2\n\n[1] FALSE\n\nx | 3 &lt; 2\n\n[1] TRUE\n\n6 != 7\n\n[1] TRUE\n\n\nՀամեմատման գործողությունները հնարավոր է օգտագործել նաև տեքստային տվյալների հետ աշխատելիս։ Երկու բառերը համեմատելիս մենք հարցնում ենք թե առաջին բառի առաջին տառը այբբենարանում երկրորդ բառի առաջին տառից ավելի շու՞տ է հանդիպում։ Եթե այո, ապա առաջին բառն ավելի փոքր է՝ &lt;, քան երկրորդ բառը։ Եթե երկու բառն էլ սկսվում են նույն տառով, ապա համեմատվում են երկրորդ տառերը և այսպես շարունակ՝\n\n\"Ararat\" &gt; \"Armenia\"\n\n[1] FALSE\n\n\nՊարզագույն տեսակ պարունակող բոլոր փոփոխականների երկարությունը 1 է, անգամ եթե փոփոխականի տեսակը տեքստային է և այն կազմված է բազմաթիվ տառերից: Երկարությունը ստացվում է length() ֆունկցիայի միջոցով, իսկ տեքստում առկա նշանների քանակը՝ nchar() ֆունկցիայի միջոցով՝\n\nx &lt;- 12\nlength(x)\n\n[1] 1\n\nx &lt;- \"This is a very long sentence\"\nlength(x)\n\n[1] 1\n\nnchar(x)\n\n[1] 28\n\n\nՄաթեմատիկայից մեզ հայտնի է, որ -1 թվի արմատը կոմպլեքս թիվ է, սակայն պետք է -ում ուշադիր լինել քանի որ sqrt(-1) հրամանը չի աշխատում։ Ըստ sqrt() ֆունկցիայի սահմանման՝ դրա վերադարձվող արժեքը ներվուծված արժեքի տեսակի է, այսինքն՝ -1 ներմուծված թիվն իրական թիվ է և վերադարձվող թիվը նույնպես պետք է իրական լինի։ Փոխարենը մենք կարող ենք կատարել՝\n\nsqrt(- 1 + 0i)\n\n[1] 0+1i\n\n\nՊարզագույն տեսակների հիման վրա կառուցվում են տվյալների պահպանման ավելի բարդ օբյեկտներ, որոնք մենք կանվանենք տվյալների պահպանման կառուցվածքներ (Data structures)։ Սրանցից առաջինը կանվանենք համասեռ վեկտոր։\n\n\n2.2.2 Համասեռ վեկտորներ (Atomic Vectors)\nՄաթեմատիկայում թվերի վերջավոր հաջորդականությունները կոչվում են վեկտորներ։ -ում նույնպես կան վեկտորներ, որոնք ունեն նույն կառուցվածքը ինչ մաթեմատիկայում՝ տարբերությամբ, որ այստեղ վեկտորները կարող են պահել ոչ միայն թվային տվյալներ։ -ում վեկտորները կարող են ունենալ նաև բարդ կառուցվածք (օրինակ -ում մատրիցը ևս համարվում է վեկտոր), այդ պատճառով մենք ներմուծում ենք համասեռ վեկտորի գաղափարը, որը վեկտորի պարզագույն տեսակն է և համապատասխանում է մաթեմատիկայի վեկտորի գաղափարին: Համասեռ վեկտոր ստեղծելու ամենահեշտ ձևը c() (անգլերեն combine՝ համախմբել բառի առաջին տառով նշանակվող) ֆունկցիան օգտագործելն է։\n\nx &lt;- c(1, 14, 5)\nx\n\n[1]  1 14  5\n\nclass(x)\n\n[1] \"numeric\"\n\n\nԻրականում անգամ մեկ թիվը իրենից ներկայացնում է վեկտոր՝ մեկ երկարությամբ։\nԻնչպես տեսնում ենք վերևում՝ փոփոխականի տեսակը նորից թվային է վերադարձվում և միակ տարբերությունը մեկ թիվ պարունակող փոփոխականից երկարությունն է, որը կարող է ստացվել length() ֆունկցիայի միջոցով։\n\nx &lt;- c(1,14,5)\nlength(x)\n\n[1] 3\n\n\nՀամասեռ վեկտորները կարող են պահել նաև ոչ թվային արժեքներ`\n\nx &lt;- c(TRUE, F)\nx\n\n[1]  TRUE FALSE\n\nclass(x)\n\n[1] \"logical\"\n\nx &lt;- c(\"Name\", \"Surname\")\nx\n\n[1] \"Name\"    \"Surname\"\n\nclass(x)\n\n[1] \"character\"\n\n\n-ում հաջորդական թվերից կազմված համասեռ վեկտոր ստեղծելու համար կարող է օգտագործվել նաև հետևյալ ֆունկցիան\n\nx &lt;- 2:6 #the same as x&lt;-c(2,3,4,5,6)\nx\n\n[1] 2 3 4 5 6\n\n\nՀամասեռ վեկտոր կարող է ստեղծվել նաև vector() ֆունկցիայի միջոցով՝\n\nx &lt;- vector(mode = \"integer\",length = 10)\nx\n\n [1] 0 0 0 0 0 0 0 0 0 0\n\n\nՍտեղծելիս ծրագիրը սկզբնական արժեքներ է տալիս վեկտորին, թվային տեսակի վեկտորների դեպքում սկզբնական արժեքը 0-ն է։\nՀամասեռ վեկտոր ստեղծելու մեկ այլ հնարավորություն է կրկնել միևնույն արժեքը որոշակի թվով անգամ։\n\nx &lt;- rep(3, times = 4)\nx\n\n[1] 3 3 3 3\n\nx &lt;- rep(c(0, 1, 2),times = 5)\nx\n\n [1] 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2\n\nx &lt;- rep(c(1, 3), each = 3)\nx\n\n[1] 1 1 1 3 3 3\n\n\nՀամասեռ վեկտոր ստեղծելու հանարավորություն է նաև : գործողությունը:\n\n1:6\n\n[1] 1 2 3 4 5 6\n\n`:`(1,6)\n\n[1] 1 2 3 4 5 6\n\npi:7\n\n[1] 3.141593 4.141593 5.141593 6.141593\n\n7:(pi-1)\n\n[1] 7 6 5 4 3\n\n\nԿամ\n\nx &lt;- seq(0,1,by=0.1)\nx\n\n [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0\n\nx &lt;- seq(0,1,length=5)\nx\n\n[1] 0.00 0.25 0.50 0.75 1.00\n\n\nՀաճախ անհրաժեշտություն է առաջանում տրված վեկտորի երկարությամբ վեկտոր ստեղծել, որը կպարունակի սկզբանական վեկտորի կոորդինատների համարակալումը: Սրա համար օգտագործվում է seq_along() ֆունկցիան՝\n\nx &lt;- c(\"First Name\", \"Last Name\", \"Position\", \"Country\")\nseq_along(x)\n\n[1] 1 2 3 4\n\n#same as\n1:length(x)\n\n[1] 1 2 3 4\n\n\nԲացի այդ՝ երբեմն անհրաժեշտ է լինում տրված երկարությամբ վեկտոր ստեղծել, որը բաղկացած կլինի հաջորդական ամբողջ թվերից: Օգտագործվում է seq_len() ֆունկցիան՝\n\nn &lt;- 6\nseq_len(n)\n\n[1] 1 2 3 4 5 6\n\n#same as \n1:n\n\n[1] 1 2 3 4 5 6\n\n\nՀամասեռ վեկտորների կարևորագույն հատկությունը միայն միևնույն տեսակի արժեքներ պահելու հնարավորությունն է։\n\n\n2.2.3 Գործողություններ վեկտորների հետ\nՀամասեռ թվային վեկտորների հետ հարմար է գործողությունները կատարելը։ Բոլոր գործողությունները կատարվում են կոորդինատ առ կոորդինատ։ Իսկ եթե վեկտորի և տարրական օբյեկտի (1 երկարությամբ վեկտորի) միջև է գործողություն կատարվում, ապա նույնպես տարրական օբյեկտի և առանձին առանձին վեկտորի կոորդինատների հետ կատարվում է այդ գործողությունը և վերադարձվում է վեկտորի երկարությամբ մեկ այլ վեկտոր՝\n\nc(-1, pi, 4) + 1:3\n\n[1] 0.000000 5.141593 7.000000\n\nc(-1, pi, 4)*1:3\n\n[1] -1.000000  6.283185 12.000000\n\nc(-1, pi, 4)/1:3\n\n[1] -1.000000  1.570796  1.333333\n\nc(-1, pi, 4)^(1:3)\n\n[1] -1.000000  9.869604 64.000000\n\nc(-1, pi, 4) + 2\n\n[1] 1.000000 5.141593 6.000000\n\n\nԵթե երկու վեկտորներ ունեն տարբեր երկարություններ, ապա մինչ գործողությունը կատարելը ծրագիրը կրկնում է կարճ վեկտորն այնքան անգամ մինչ դրա երկարությունը կհավասարվի երկարին, ապա կատարում գործողությունը։\n\nc(1, 3, 5, 8)/c(2, 4)\n\n[1] 0.50 0.75 2.50 2.00\n\n\nԻրականում վեկտորի և տարրական փոփոխականի միչև վերը նշված գործողությունը ևս նույն սկզբունքով է կատարվում, օրինակ, երբ վեկտորը բազմապատկվում է թվով, այդ թիվը կրկնվում է վեկտորի երկարության քանակով, ապա կատարվում է գործողությունը՝\n\n1:4*2\n\n[1] 2 4 6 8\n\n1:4*c(2, 2, 2, 2)\n\n[1] 2 4 6 8\n\n\nՆույն սկզբունքը գործում է նաև տրամաբանական գործողություններ կատարելիս՝\n\n1:10 &lt; 5\n\n [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n\n\nԵթե երկար վեկտորի երկարությունն առանց մնացորդի չի բաժանվում կարճ վեկտորի երկարությանը, այն է՝ կարճը կրկնելով հնարավոր չէ հավասարեցնել երկարի երկարությանը, ապա գործողությունն այնուամենայնիվ կկատարվի բայց ծրագիրը կտա նաև զգուշացում՝\n\n1:5/c(1, 2)\n\nWarning in 1:5/c(1, 2): longer object length is not a multiple of shorter\nobject length\n\n\n[1] 1 1 3 2 5\n\n\nՀամասեռ վեկտորների հետ աշխատելիս կարևոր է ստուգելու գործողությունը, թե արդյոք որևէ արժեք կամ արժեքներ այդ վեկտորի մեջ են, թե՞ ոչ։\n\n\"Writing\" %in% c(\"Speaking\", \"Writing\", \"Listening\", \"Reading\")\n\n[1] TRUE\n\nc(3, 5) %in% 1:4\n\n[1]  TRUE FALSE\n\n1:4 %in% c(4, 3)\n\n[1] FALSE FALSE  TRUE  TRUE\n\n\nՎերադարձվում է առաջին վեկտորի երկարության վեկտոր, որը պարունակում է տրամաբանական արժեքներ, կախված նրանից, թե արդյոք առաջին վեկտորի համապատասխան կոորդինատը պարունակվում է երկրորդ վեկտորում։\n\n\n2.2.4 Տեսակի փոփոխություն (Type Coercion)\nԻնչպես նշվեց՝ համասեռ վեկտորներում կարող են պահվել միայն միևնույն տեսակի արժեքներ։ Երբ փորձենք ստեղծել համասեռ վեկտոր և դրանում պահել տարբեր տեսակի արժեքներ, ապա ոչ թե սխալ տեղի կունենա այլ՝ տեսակի հարկադիր փոփոխություն՝\n\nx &lt;- c(F, 12)\nx\n\n[1]  0 12\n\nclass(x)\n\n[1] \"numeric\"\n\nx &lt;- c(TRUE, 1L)\nx\n\n[1] 1 1\n\nclass(x)\n\n[1] \"integer\"\n\nx &lt;- c(21, \"12\")\nx\n\n[1] \"21\" \"12\"\n\nclass(x)\n\n[1] \"character\"\n\n\n-ն այս դեպքերում կատարում է տեսակի ոչ բացահայտ փոփոխություն։ Հնարավոր է նաև կատարել տեսակների բացահայտ փոփոխություն՝ օգտագործողի ցանկությամբ։\n\nx &lt;- 0:10\nclass(x)\n\n[1] \"integer\"\n\ny &lt;- as.character(x)\ny\n\n [1] \"0\"  \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\"\n\ny &lt;- as.logical(x)\ny\n\n [1] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n\ny &lt;- as.complex(x)\ny\n\n [1]  0+0i  1+0i  2+0i  3+0i  4+0i  5+0i  6+0i  7+0i  8+0i  9+0i 10+0i\n\nx &lt;- c(\"1\", \"2\", \"3\")\ny &lt;- as.numeric(x)\ny\n\n[1] 1 2 3\n\n\nԲնականաբար տեսակի փոփոխությունը ոչ միշտ է հնարավոր՝\n\nx &lt;- c(\"a\",\"b\",\"c\")\nas.logical(x)\n\n[1] NA NA NA\n\n\nNA հերթական հատուկ արժեքն է, որը ցույց է տալիս որ տվյալ արժեքը գոյություն չունի՝ Not assigned: Տեսակի փոփոխման հերթականությունը հետևյալն է՝\nLogical -&gt; integer -&gt; numeric -&gt; complex -&gt; character\n\n\n2.2.5 Բացակայող արժեքներ (Missing Values)\nԻնչպես նշվեց վերևում՝ -ում արժեքի բացակայությունը ցույց տվող արժեքներն են NA և NaN արժեքները, որոնցից վերջինը նախատեսված է չսահմանված մաթեմատիկական գործողությունները ցույց տալու համար։ Որպեսզի պարզենք թե փոփոխականի մեջ պահվող արժեքը բացակայող արժեքի ինչ տիպ ունի, օգտագործվում է is.na() ֆունկցիան, որը վերադարձնում է տրամաբանական արժեքներ՝ այո կամ ոչ։ Նմանապես գործում է նաև is.nan() ֆունկցիան։ NaN տեսակի արժեք ունեցող փոփոխականը նաև NA տեսակի է, բայց հակառակը ճիշտ չէ։\n\nx &lt;- NA\nis.na(x)\n\n[1] TRUE\n\nis.nan(x)\n\n[1] FALSE\n\nx &lt;- NaN\nis.na(x)\n\n[1] TRUE\n\nis.nan(x)\n\n[1] TRUE\n\n\nՀատուկ արժեքների հետ աշխատելիս սովորական == գործողությամբ հնարավոր չէ հավասարություն ստուգել, այդ պատճառով էլ անհրաժեշտ է օգտագործել վերը նշված ֆունկցիաները՝\n\nx &lt;- NA\nx\n\n[1] NA\n\nx == NA\n\n[1] NA\n\n\nԱրժեքի բացակայությունը ցույց տվող արժեքի՝ NA կարևոր առանձնահատկություններից է, որ այն հայտնվելով համասեռ վեկտորում՝ չի փոխում վեկտորի տեսակը: (NaN տեսակը թվային է, հետևաբար այն ընդգրկելով այլ տեսակի համասեռ վեկտորներում դրա տեսակը կփոխվի):\n\nx &lt;- c(\"1\", NA, \"2\", NA)\nclass(x)\n\n[1] \"character\"\n\nclass(NaN)\n\n[1] \"numeric\"\n\nc(\"1\", NaN)\n\n[1] \"1\"   \"NaN\"\n\n\nՍրա պատճառը NA արժեքի որպես տրամաբանական արժեք սահմանված լինելն է, այդ պատճառով հայտնվելով այլ տեսակների համասեռ վեկտորներում այն կարողանում է փոխել իր տեսակը և դառնալ իրեն ընդգրկող վեկտորի տեսակի (տրամաբանական տեսակը ամենափոքր տեսակն է և այն հնարավո է ցանկացած այլ տեսակի վերածել)։\n\nclass(NA)\n\n[1] \"logical\"\n\n\nԿիրառելով այս վեկտորների վրա բացակայող արժեքները հայտնաբերող ֆունկցիաները, կստանանք այն կոորդինատները, որտեղ գրված են բացակայող արժեքները՝\n\nx &lt;- c(1, NaN, 2, NA)\nis.na(x)\n\n[1] FALSE  TRUE FALSE  TRUE\n\nis.nan(x)\n\n[1] FALSE  TRUE FALSE FALSE\n\ny &lt;- c(\"1\", NA, \"2\", NA)\nclass(y)\n\n[1] \"character\"\n\nis.na(x)\n\n[1] FALSE  TRUE FALSE  TRUE\n\n\nԱյս ֆունկցիաները կիրառելիս նկատում ենք -ի կարևորագույն առանձնահատկություններից մեկը, որը հետագայում ավելի մանրամասն կքննարկվի։ Նշված ֆունկցիաներ որպես արգումենտ ընդունում են համասեռ վեկտոր, գործողությունը կատարում են յուրաքանչյուր կոորդինատի համար՝ առանձին առաձին, ապա վերադարձնում արժեքներից կազմված վեկտոր, որը ունի սկզբնական վեկտորին հավասար երկարություն (Vectorized function)։ Այս առանձնահատկության շնորհիվ շրջապտույտի ֆունկցիաների օգտագործումից (Loop) հաճախ հնարավոր է լինում խուսափել, այդպիսով՝ ավելի արագացնելով և արդյունավետ դարձնելով գործողությունների կատարումը։\nՆախասահմանված sum() ֆունկցիան որպես արգումենտ ստանալով համասեռ թվային վեկտոր վերադարձնում է այդ վեկտորի կոորդինատների գումարը՝\n\nsum(1:10)\n\n[1] 55\n\n\nԱյս ֆունկցիայի միջոցով հնարավոր է հաշվել համասեռ վեկտորում առկա բացակայող արժեքների՝ NA-ների քանակը՝\n\nx &lt;- c(\"A\", NA, NA, NA, \"B\", NA, \"1\", NA, NA)\nis.na(x)\n\n[1] FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE  TRUE\n\nsum(is.na(x))\n\n[1] 6\n\n\nԻնչպես նշվեց՝ sum() ֆունկցիան որպես արգումենտ ընդունում է համասեռ թվային վեկտորներ, հետևաբար դա կիրառելով համասեռ, տրամաբանական արժեքներ պարունակող վեկտորների վրա (որը ստացվում է is.na() ֆունկցիան կանչելու արդյունքում), տեղի է ունենում տեսակի քողարկված փոփոխություն, ինչպես հետևյալ ֆունկցիան կանչելիս՝\n\nas.numeric(is.na(x))\n\n[1] 0 1 1 1 0 1 0 1 1\n\n\nԵվ վերցնելով այս վեկտորի կոորդինատների գումարը՝ կստանանք 1-երի քանակը, իսկ վերջիններս համապատասխանում են բացակայող արժեքները ցույց տվող TRUE արժեքներին։\n\n\n2.2.6 Ենթավեկտոր (Subsetting a Vector)\n-ում գոյություն ունի համասեռ վեկտորից ենթավեկտոր ստանալու 4 ձև՝ 1. դրական ամբողջ թվերի միջոցով, 2. բացասական ամբողջ թվերի միջոցով, 3. տրամաբանական արժեքների միջոցով, և 4. անունների միջոցով:\n\nՊարզագույն ձևը դրական ամբողջ թվերի միջոցով ենթավեկտոր ստանալն է։\n\nԵթե տրված է որոշակի արժեքներից կազմված վեկտոր, ապա գտնելով այդ վեկտորի երկարությունը length() ֆունկցիայի միջոցով հնարավոր է 1-ից (հաշվումը -ում սկսվում է 1-ից) մինչ երկարությունն ընկած թվերի միջոցով ստանալ վեկտորի համապատասխան կոորդինատը կամ կոորդինատները՝ օգտագործելով [ ] փակագծերը՝ վեկտորի անունից հետո\n\nx &lt;- c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\")\nx[1]\n\n[1] \"a\"\n\nx[5]\n\n[1] \"e\"\n\n\nՀնարավոր է նաև միաժամանակ ստանալ համասեռ վեկտորի մի քանի կոորդինատներ, այդպիսով ստանալով տրված վեկտորի ենթավեկտոր՝\n\nx[1:5]\n\n[1] \"a\" \"b\" \"c\" \"d\" \"e\"\n\nx[c(1, 3)]\n\n[1] \"a\" \"c\"\n\nx[c(length(x) - 1, length(x))] #the last two elements\n\n[1] \"h\" \"i\"\n\ny &lt;- c(1:3, 5)\nx[y]\n\n[1] \"a\" \"b\" \"c\" \"e\"\n\nx[]\n\n[1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\"\n\n\nԵրբ ենթավեկտոր կառուցելիս օգտագործվում է սկզբնական վեկտորի երկարությունը գերազանցող թիվ, ապա ծրագրային սխալ տեղի չի ունենում, ոչ էլ զգուշացում է հայտնվում։ Պարզապես վերադարձվում է անհայտ արժեք։\n\nx &lt;- c(\"1\", \"B\", \"Complex\")\nlength(x)\n\n[1] 3\n\nx[4]\n\n[1] NA\n\n\nԱյս առանձնահատկության շնորհիվ հնարավոր է նոր կոորդինատներ ավելացնել վեկտորին՝\n\nx &lt;- 1:10\nx[length(x) + 1] &lt;- 0\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10  0\n\nx[length(x) + 10] &lt;- -1\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10  0 NA NA NA NA NA NA NA NA NA -1\n\n\n\nԵնթավեկտոր ստանալու հաջորդ ձևը բացասական ամբողջ թվեր օգտագործելն է։ Եթե դրական ամբողջ թվերն օգտագործվում են ընտրելու համար անհրաժեշտ կոորդինատները, ապա բացասական ամբողջ թվերն օգտագործվում են դուրս թողնելու համար համապատասխան համարն ունեցող կոորդինատները։ (Դրական և բացասական թվերի միաժամանակյա օգտագործումն արգելված է։)\n\n\nx &lt;- 1:10\nx[- c(1, 2, 3)]\n\n[1]  4  5  6  7  8  9 10\n\nx[-1:-3]\n\n[1]  4  5  6  7  8  9 10\n\ny &lt;- seq(0, 1, by = 0.01)\ny[x]\n\n [1] 0.00 0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09\n\n\n\nԵնթավեկտոր ստանալու հաջորդ ձևը տրամաբանական արժեքներ պարունակող, սկզբնական վեկտորի երկարությանը հավասար երկարություն ունեցող վեկտոր օգտագործելն է, որը TRUE արժեքների միջոցով ցույց կտա թե սկզբնական վեկտորի որ կոորդինատներն է պետք ընտրել։\n\n\nx &lt;- 1:4\ny &lt;- c(T, F, T, F)\nx[y]\n\n[1] 1 3\n\n\nԵնթավեկտոր ընտրելու այս ձևն առավելապես օգտակար է, երբ տրամաբանական արժեքներ պարունակող վեկտորը ստացվել է սկզբանական վեկտորի հետ համեմատման գործողություններ կատարելիս։ Օրինակ, ենթադրենք համասեռ, թվային վեկտորից պետք է հեռացնել բոլոր բացասական թվերը, ապա նախ կստեղծենք տրամաբանական արժեքներ պարունակող վեկտոր, որը FALSE արժեքներ կպարունակի բացասական արժեքներին համապատասխան, այնուհետև, օգտագործելով այդ վեկտորը հնարավոր է սկզբնական վեկտորից համապատասխան ենթավեկտոր ստանալ։\n\nx &lt;- -10:10\nx\n\n [1] -10  -9  -8  -7  -6  -5  -4  -3  -2  -1   0   1   2   3   4   5   6   7   8\n[20]   9  10\n\nx[x &gt;= 0]\n\n [1]  0  1  2  3  4  5  6  7  8  9 10\n\n\nԱյս հնարքը հաճախ օգտագործվում է վեկտորից անհայտ արժեքները հեռացնելու համար՝\n\nx &lt;- c(10, NA, -5, NA, NA, 0, -33, 12.4)\nx[!is.na(x)]\n\n[1]  10.0  -5.0   0.0 -33.0  12.4\n\nx[!is.na(x) & x &gt;= 0]\n\n[1] 10.0  0.0 12.4\n\n\nԱյս դեպքում նույնպես եթե ենթավեկտոր ստանալու համար նախատեսված տրամաբանական վեկտորը կարճ է սկզբանական վեկտորից, ապա այն կրկնվում է մինչ սկզբնական վեկտորի երկարությանը հասնելը՝\n\nx &lt;- 1:3\nx[c(TRUE, FALSE)] #the same as x[c(TRUE,FALSE,TRUE)]\n\n[1] 1 3\n\n\n\nԵնթավեկտոր ստանալու վերջին ձևը անունների կոորդինատներին տրված անոււնների միջոցով է։ Նախ քննարկենք, թե ինչպես է հնարավոր համասեռ վեկտորի կոորդինատներին անուններ տալ։\n\n\nx &lt;- c(a = 1, b = 2/3, c = sqrt(3), number = -12)\nx\n\n          a           b           c      number \n  1.0000000   0.6666667   1.7320508 -12.0000000 \n\n\nՈւշադրություն դարձրեք, որ այստեղ օգտագործվում է = նշանը։\nԱնունները հնարավոր է ստանալ names() ֆունկցիայի միջոցով՝\n\nnames(x)\n\n[1] \"a\"      \"b\"      \"c\"      \"number\"\n\n\nԻրականում վեկտորին հնարավոր է նաև անուններ տալ այս ֆունկցիայի միջոցով, կամ փոխել նախկինում տրված անունները՝\n\nx &lt;- c(a = 1, b = 2/3, c = sqrt(3), number = -12)\nx\n\n          a           b           c      number \n  1.0000000   0.6666667   1.7320508 -12.0000000 \n\nnames(x) &lt;- c(\"Integer\", \"Rational\", \"Irrational\", \"Negative\")\nx\n\n    Integer    Rational  Irrational    Negative \n  1.0000000   0.6666667   1.7320508 -12.0000000 \n\n\nԵթե վեկտորի կոորդինատներին վերագրում ենք անունների վեկտոր, որն ավելի կարճ է, ապա կարճ վեկտորի կրկնում տեղի ՉԻ ունենում, այլ պարզապես վերջին կորրդինատներն անուններ չեն ստանում՝\n\ny &lt;- x\ny\n\n    Integer    Rational  Irrational    Negative \n  1.0000000   0.6666667   1.7320508 -12.0000000 \n\nnames(y) &lt;- \"A name\"\ny\n\n     A name        &lt;NA&gt;        &lt;NA&gt;        &lt;NA&gt; \n  1.0000000   0.6666667   1.7320508 -12.0000000 \n\n\nԵթե համասեռ վեկտորի կոորդինատներն ունեն անուններ, ապա ենթավեկտոր կարելի է ստանալ նաև այսպես՝\n\nx\n\n    Integer    Rational  Irrational    Negative \n  1.0000000   0.6666667   1.7320508 -12.0000000 \n\nx[\"Rational\"]\n\n Rational \n0.6666667 \n\nx[c(\"Rational\",\"Irrational\")]\n\n  Rational Irrational \n 0.6666667  1.7320508 \n\n\nԱնունով ենթավեկտոր ընտրելն ավելի նախընտրելի է քանի որ համասեռ վեկտորների հետ գործողություններ կատարելիս և դրանց երկարությունը փոխելիս կոորդինատի նախնական դիրքը կարող է փոխվել, իսկ անունը կմնա նույնը։ Հաճախ հնարավոր է նախ կոորդինատների դիրքերի փոփոխություն` գոյություն ունեցող վեկտորի ներսում։\n\n# extract the irrational number\nx[3]\n\nIrrational \n  1.732051 \n\nx[\"Irrational\"]\n\nIrrational \n  1.732051 \n\n#extract the irrational number after adding the 0 number\ny &lt;- c(0, x); y\n\n                Integer    Rational  Irrational    Negative \n  0.0000000   1.0000000   0.6666667   1.7320508 -12.0000000 \n\ny[3]\n\n Rational \n0.6666667 \n\ny[\"Irrational\"]\n\nIrrational \n  1.732051 \n\n\nԿոորդինատի անվանման միջոցով կոորդինատը ուղիղ ձևով հեռացնել հնարավոր չէ, բայց հնարավոր է անվան միջոցով կոորդինատի համարը գտնել և դրան միջոցով այն օգտագործել։ Օգտագործելու ենք \\(which()\\) ֆունկցիան, որը ստանալով տրամաբանական, համասեռ վեկտոր վերադարձնում է այն համարները որտեղ TRUE է գրված՝\n\nz &lt;- c(T, F, F, T, F, F, T)\nwhich(z)\n\n[1] 1 4 7\n\n\nՀետևաբար, իռացիոնալ թիվը վերը սահմանված վեկտորից հեռացնելու համար նախ պետք է գտնել այդ կոորդինատի համարը՝\n\nx\n\n    Integer    Rational  Irrational    Negative \n  1.0000000   0.6666667   1.7320508 -12.0000000 \n\nnames(x) == \"Irrational\"\n\n[1] FALSE FALSE  TRUE FALSE\n\nx[-which(names(x) == \"Irrational\")]\n\n    Integer    Rational    Negative \n  1.0000000   0.6666667 -12.0000000 \n\n\nԻհարկե, հնարավոր է նաև տրված անունով կոորդինատը հեռացնել ընտրելով միայն այն կոորդինատները, որոնց անունը հավասար չէ տրված անվանը։\n\nx[names(x) != \"Irrational\"]\n\n    Integer    Rational    Negative \n  1.0000000   0.6666667 -12.0000000 \n\n\nԱյս երկու մեթոդներով կարող ենք հեռացնել նաև մեկից ավելի կոորդինատներ՝ իրենց անունների միջոցով։\n\nx[-which(names(x) %in% c(\"Irrational\", \"Rational\"))]\n\n Integer Negative \n       1      -12 \n\nx[!names(x) %in% c(\"Irrational\", \"Rational\")]\n\n Integer Negative \n       1      -12 \n\n\nԷրատոսթենեսի մաղը (The Sieve of Eratosthenes )\nՏրված բնական թվերի վերջավոր հաջորդականություն և պետք է հեռացնել դրանցից թվերն այնպես, որ մնան միայն պարզ թվերը։ Ալգորիթմը հետևյալն է՝ նախ հեռացվում է 1 թիվը, այնուհետև հեռացվում են 2-ի վրա բաժանվող թվերը, բայց ոչ 2-ն ինքը և այսպես շարունակ հեռացվում են հաջորդ բնական թվի վրա բաժանվող թվերը։ Այս գործընթացը կարիք չկա շարունակելու մինչ սկզբում տրված ամենամեծ բնական թվի արմատը չգերազանցող բնական թիվը՝\n\nstart &lt;- Sys.time()\nn &lt;- 1000\nX &lt;- seq_len(n)\nX &lt;- X[X &gt; 1]\nfor(x in X)\n  X &lt;- X[X %% x != 0 | X == x]\n\nend &lt;- Sys.time()\nX\n\n  [1]   2   3   5   7  11  13  17  19  23  29  31  37  41  43  47  53  59  61\n [19]  67  71  73  79  83  89  97 101 103 107 109 113 127 131 137 139 149 151\n [37] 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251\n [55] 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349 353 359\n [73] 367 373 379 383 389 397 401 409 419 421 431 433 439 443 449 457 461 463\n [91] 467 479 487 491 499 503 509 521 523 541 547 557 563 569 571 577 587 593\n[109] 599 601 607 613 617 619 631 641 643 647 653 659 661 673 677 683 691 701\n[127] 709 719 727 733 739 743 751 757 761 769 773 787 797 809 811 821 823 827\n[145] 829 839 853 857 859 863 877 881 883 887 907 911 919 929 937 941 947 953\n[163] 967 971 977 983 991 997\n\nend-start\n\nTime difference of 0.01245117 secs\n\n\nfor() կառուցվածքին մանրամասնորեն դեռևս կանդրադառնանք, իսկ Sys.time() ֆունկցիան վերադարձնում է ժամանակի այն պահը երբ այն կանչվել է։\nԿանչելով այդ ֆունկցիան մինչ ծրագրի սկիզբը և ամենավերջում, ապա վերցնելով ժամանակի այդ պահերի տարբերությունը կստանանք թե ինչքան ժամանակ է պահանջվել ծրագրից հաշվարկները կատարելու համար։ Այդպես հնարավոր է ստուգել գրված ծրագրի արդյունավետությունը՝ կախված նրանից թե ինչքան արագ է այն կատարվում:\n\n\n2.2.7 Օբյեկտների հատկանիշեր (Attributes)\nՀաճախ -ում օբյեկտներն ունեն հատկանիշներ (attributes), որոնցից են\n\nnames, dimnames - անուններ, չափողականության անուններ\ndimensions չափողականություններ\nclass - տեսակ\nօգտագործողի կողմից սահմանված այլ հատկանիշերը\n\nՕբյեկտի բոլոր հատկանիշերը կարելի է ստանալ attributes() ֆունկցիայի միջոցով։ Օրինակ հնարավոր է համասեռ վեկտորի արժեքներին անուններ տալ՝\n\nx &lt;- c(a = 1, b = 12)\nx\n\n a  b \n 1 12 \n\nclass(x)\n\n[1] \"numeric\"\n\nattributes(x)\n\n$names\n[1] \"a\" \"b\"\n\n\nՈւշադրություն դարձրեք, որ այստեղ օգտագործվում է = նշանը։\nnames հատկանիշը հնարավոր է ստանալ attr() ֆունկցիայի միջոցով՝\n\nattr(x, \"names\")\n\n[1] \"a\" \"b\"\n\n\nՀիմանկան հատկանիշները, ինչպիսիք են չափողականությունը, տեսակը, անունները և չափողականությունների անունները հնարավոր է ստանալ նաև համապատասխան names(), dim(), class(), dimnames() ֆունկցիաների միջոցով՝\n\nnames(x) #attr(x,\"names\")\n\n[1] \"a\" \"b\"\n\n\nՕգտագործողը հնարավորություն ունի սահմանելու նոր հատկանիշներ։ Ինչպես նշվեց -ում փոփոխականի անունները սահմանելիս տեղի ունեն որոշակի սահմանափակումներ։ Այդ պատճառով, եթե օգտագործողն ուզում է փոփոխականի վերաբերյալ լրացուցիչ տվյալ պահել, ապա կարող է սահմանել պիտակ՝ label, և այդտեղ պահել փոփոխականի վերաբերյալ ավելի լիակատար նկարագրություն՝\n\nyears &lt;- 2012:2015\nnames(years) &lt;- c(\"Y1\", \"Y2\", \"Y3\", \"Y4\")\nattr(years,\"label\") &lt;- \"Years of data collection\"\nyears\n\n  Y1   Y2   Y3   Y4 \n2012 2013 2014 2015 \nattr(,\"label\")\n[1] \"Years of data collection\"\n\nattributes(years)\n\n$names\n[1] \"Y1\" \"Y2\" \"Y3\" \"Y4\"\n\n$label\n[1] \"Years of data collection\"\n\n\nՎեկտորը փոփոխության ենթարկելիս դրա հատկանիշները կորում են, բացառությամբ վերը նշված հիմնական հատկանիշների՝\n\nyears &lt;- years[-1]\nyears\n\n  Y2   Y3   Y4 \n2013 2014 2015 \n\nattributes(years)\n\n$names\n[1] \"Y2\" \"Y3\" \"Y4\"\n\n\n\n\n2.2.8 Մատրիցներ (Matrices)\nՎեկտորների միջոցով կարող ենք ստանալ այլ կառուցվածքներ, մասնավորապես մատրիցներ, որոնք վեկտորներ են լրացուցիչ՝ չափողականություն հատկանիշով։ Չափողականությունն իր հերթին համասեռ, ամբողջ թվերից կազմված վեկտոր է՝ երկու երկարությամբ և իր մեջ պարունակում է տողերի և սյուների քանակը։ Վերցնենք համասեռ, թվային վեկտոր և դրան հաղորդենք չափողականություն հատկանիշը և տեսնենք ինչ է ստացվում՝\n\nx &lt;- 1:10\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nattributes(x)\n\nNULL\n\n\nՀամասեռ վեկտորը հատկանիշներ չունի։ Այս վեկտորի համար սահմանենք չափողականություն՝\n\ndim(x) &lt;- c(2, 5)\nattributes(x)\n\n$dim\n[1] 2 5\n\ndim(x)\n\n[1] 2 5\n\n\nԱյժմ տեսնենք թե ինչպես է փոխվել համասեռ վեկտորի տեսքը և ինչպիսինն է դրա նոր կառուցվածքը՝\n\nx\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    3    5    7    9\n[2,]    2    4    6    8   10\n\nclass(x)\n\n[1] \"matrix\" \"array\" \n\n\nՄատրից ստեղծելու պարզագույն ձևը \\(matrix()\\) ֆունկցիայի միջոցով է՝\n\nx &lt;- matrix()\nattributes(x)\n\n$dim\n[1] 1 1\n\nx\n\n     [,1]\n[1,]   NA\n\nx &lt;- matrix(nrow = 2, ncol = 3)\nx\n\n     [,1] [,2] [,3]\n[1,]   NA   NA   NA\n[2,]   NA   NA   NA\n\n\nՍտեղծեցինք դատարկ մատրից, որը ծրագրի կողմից լրացվեց \\(NA\\) հատուկ արժեքներով։ Ինչպես տեսնում ենք՝ ցանկացած մատրից ստեղծելիս ստեղծվում է նաև դրա չափողականություն հատկանիշը։ Օգտագործելով \\(dim()\\) ֆունկցիան՝ մենք կարող ենք ստանալ մատրիցի չափողականությունը պարունակող վեկտորը՝\n\nattributes(x)\n\n$dim\n[1] 2 3\n\ndim(x)\n\n[1] 2 3\n\n\nԱյստեղ առաջին թիվը ցույց է տալիս տողերի քանակը, իսկ երկրորդը՝ սյուների։ Կարող ենք նաև օգտագործել \\(nrow(),\\,ncol()\\) ֆունկցիաները ստանալու համար համապատասխանաբար մատրիցի տողերի և սյուների քանակները։\n\nnrow(x); ncol(x)\n\n[1] 2\n\n\n[1] 3\n\n\nՄատրիցը ստեղծելիս մենք կարող էինք տալ այն արժեքները որոնցով կառուցվում է մատրիցը՝ համասեռ վեկտորի տեսքով՝\n\nx &lt;- matrix(data = 1:6, ncol = 3, nrow = 2)\nx\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n\nՄատրիցները կազմվում են սյուններով, այսինքն՝ տրված համասեռ վեկտորի արժեքները տեղադրվում են վերևի ձախ անկյունից և ներքև իջնում սյուներով։ Տող առ տող լրացնելու համար պետք է արգումենտներից մեկում փոխել լռելյալ արժեքը (default value)\n\nx &lt;- matrix(data = 1:6, ncol = 3, nrow = 2, byrow = TRUE)\nx\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n\n\nՄատրիցներ ստեղծելու վերջին ձևը համասեռ վեկտորները իրար որպես սյուներ կամ տողեր միացնելն է, որոնք կատարվում են \\(cbind(),\\,rbind()\\) ֆունկցիաների միջոցով՝\n\nx &lt;- 12:14\ny &lt;- 28:30\nm &lt;- rbind(x, y)\nm\n\n  [,1] [,2] [,3]\nx   12   13   14\ny   28   29   30\n\nclass(m)\n\n[1] \"matrix\" \"array\" \n\nm &lt;- cbind(x, y)\nm\n\n      x  y\n[1,] 12 28\n[2,] 13 29\n[3,] 14 30\n\n\nՀիշենք, որ մատրիցը կարող է պարունակել միայն նույն տեսակի արժեքներ, բայց ոչ պարտադիր թվային՝\n\nx &lt;- matrix(data = c(\"a\", \"b\", \"c\", \"d\"), ncol = 2, nrow = 2)\nclass(x)\n\n[1] \"matrix\" \"array\" \n\nx\n\n     [,1] [,2]\n[1,] \"a\"  \"c\" \n[2,] \"b\"  \"d\" \n\ntypeof(x)\n\n[1] \"character\"\n\n\nԻնչպես և համասեռ վեկտորների դեպքում, եթե փորձենք մատրիցին ավելացնել այլ տեսակի սյուն կամ տող, տեղի կունենա տեսակի քողարկված փոփոխություն՝\n\nx &lt;- matrix(data = 1:6, ncol = 3, nrow = 2, byrow = TRUE)\ntypeof(x)\n\n[1] \"integer\"\n\nx\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n\nx_ &lt;- rbind(x, c(\"a\", \"b\", \"c\"))\ntypeof(x_)\n\n[1] \"character\"\n\nx_\n\n     [,1] [,2] [,3]\n[1,] \"1\"  \"2\"  \"3\" \n[2,] \"4\"  \"5\"  \"6\" \n[3,] \"a\"  \"b\"  \"c\" \n\n\n\n\n2.2.9 Գործողություններ մատրիցների հետ\nԹվային մատրիցների հետ գործողությունների կանոները գրեթե նույնն են ինչ համասեռ, թվային վեկտորների հետ գործողությունների կանոները։ Նախ կիրառենք \\(length()\\) ֆունկցիան որևէ մատրիցի վրա՝\n\nx &lt;- matrix(data = 1:6, ncol = 3, nrow = 2, byrow = TRUE)\nlength(x)\n\n[1] 6\n\n\nԱյն վերադարձնում է մատրիցի էլեմենտների քանակը։ Այս մատրիցի հետ թվաբանական գործողություններ կատարելիս -ը դրան վերաբերվում է որպես սովորական համասեռ, թվային վեկտորի՝ կարդացված սյուն առ սյուն։\n\ny &lt;- 1:6\nx+y\n\n     [,1] [,2] [,3]\n[1,]    2    5    8\n[2,]    6    9   12\n\nx*y\n\n     [,1] [,2] [,3]\n[1,]    1    6   15\n[2,]    8   20   36\n\nx/y\n\n     [,1]      [,2] [,3]\n[1,]    1 0.6666667  0.6\n[2,]    2 1.2500000  1.0\n\nx^y\n\n     [,1] [,2]  [,3]\n[1,]    1    8   243\n[2,]   16  625 46656\n\n\nՆույն արդյունքը կստացվեր, եթե \\(y\\) համասեռ վեկտորը մատրից լիներ՝\n\ny &lt;- matrix(y, ncol = 3)\nx+y\n\n     [,1] [,2] [,3]\n[1,]    2    5    8\n[2,]    6    9   12\n\nx*y\n\n     [,1] [,2] [,3]\n[1,]    1    6   15\n[2,]    8   20   36\n\nx/y\n\n     [,1]      [,2] [,3]\n[1,]    1 0.6666667  0.6\n[2,]    2 1.2500000  1.0\n\nx^y\n\n     [,1] [,2]  [,3]\n[1,]    1    8   243\n[2,]   16  625 46656\n\n\nՆմանապես նույնն են նաև տրված մատրիցի և ավելի կարճ երկարություն ունեցող վեկտորի (կամ մատրիցի) հետ գործողություններ կատարելու կանոնները՝\n\nx\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n\nx + 1\n\n     [,1] [,2] [,3]\n[1,]    2    3    4\n[2,]    5    6    7\n\nx + c(1, 2)\n\n     [,1] [,2] [,3]\n[1,]    2    3    4\n[2,]    6    7    8\n\nx + c(1, 2, 3)\n\n     [,1] [,2] [,3]\n[1,]    2    5    5\n[2,]    6    6    9\n\nx + c(1, 2, 3, 4)\n\nWarning in x + c(1, 2, 3, 4): longer object length is not a multiple of shorter\nobject length\n\n\n     [,1] [,2] [,3]\n[1,]    2    5    4\n[2,]    6    9    8\n\n\nԿամ տրամաբանական գործողություններ կատարելիս՝\n\nx &gt; c(1, 2, 3)\n\n      [,1]  [,2] [,3]\n[1,] FALSE FALSE TRUE\n[2,]  TRUE  TRUE TRUE\n\n\nՊետք է ուշադիր լինել, որ գումարվող մատրիցը նույն չափողականությունն ունենա ինչ սկզբնական մատրիցը կամ առհասարակ չափողականություն չունենա՝\n\nx + matrix(1)\n\n\n\n[1] \"Error in x + matrix(1) : non-conformable arrays\\n\"\n\n\nԲնականաբար կառուցվածքի մատրից լինելու հանգամանքը նաև լրացուցիչ հնարավորություններ է ընձեռում։ Օրինակ հնարավոր է մատրիցային բազմապատկում կատարելը՝\n\nx &lt;- matrix(1:4, ncol = 2)\nx\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\ny &lt;- matrix(c(1, 0, 0, 1), ncol = 2)\ny\n\n     [,1] [,2]\n[1,]    1    0\n[2,]    0    1\n\nx %*% x\n\n     [,1] [,2]\n[1,]    7   15\n[2,]   10   22\n\nx %*% y\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n\nՔառակուսային, չվերասերված (ոչ զրոյական որոշիչ ունեցող) մատրիցի հակադարձը հնարավոր է հաշվել \\(solve()\\) ֆունկցիայի միջոցով։ Քառակուսային մատրիցի որոշիչը հնարավոր է հաշվել \\(det()\\) ֆունկցիայի միջոցով՝\n\nx\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\ndet(x)\n\n[1] -2\n\nsolve(x)\n\n     [,1] [,2]\n[1,]   -2  1.5\n[2,]    1 -0.5\n\nx %*% solve(x)\n\n     [,1] [,2]\n[1,]    1    0\n[2,]    0    1\n\n\nՄատրիցային հանրահաշվի կարևորագույն գործողություններից է մատրիցի տրասնպոնացումը՝ գլխավոր անկյունագծի նկատմամբ շրջումը՝\n\nx\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\nt(x)\n\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n\nx &lt;- matrix(letters[1:6], ncol = 3)\nx\n\n     [,1] [,2] [,3]\n[1,] \"a\"  \"c\"  \"e\" \n[2,] \"b\"  \"d\"  \"f\" \n\nt(x)\n\n     [,1] [,2]\n[1,] \"a\"  \"b\" \n[2,] \"c\"  \"d\" \n[3,] \"e\"  \"f\" \n\n\n\n\n2.2.10 Ցուցակներ (Lists)\nՀամասեռ վեկտորներից հետո վեկտորի կարևոր օրինակներից են ցուցակները։ Սրանք տվյալների կառուցվածքների յուրահատուկ օրինակ են նրանով, որ կարող են պահել տարբեր տեսակի արժեքներ, նաև տարբեր տեսակի կառուցվածքներ, այդ թվում՝ այլ ցուցակներ։\n\nx &lt;- list(1, \"a\", TRUE, 1+4i)\nx\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] \"a\"\n\n[[3]]\n[1] TRUE\n\n[[4]]\n[1] 1+4i\n\nclass(x)\n\n[1] \"list\"\n\nlength(x)\n\n[1] 4\n\ny &lt;- list(1:10, x)\nlength(y)\n\n[1] 2\n\ny\n\n[[1]]\n [1]  1  2  3  4  5  6  7  8  9 10\n\n[[2]]\n[[2]][[1]]\n[1] 1\n\n[[2]][[2]]\n[1] \"a\"\n\n[[2]][[3]]\n[1] TRUE\n\n[[2]][[4]]\n[1] 1+4i\n\n\nԻնչպես տեսնում եք վերը նշված ցուցակի երկարությունը երկուս է (թեև երկրորդ կոորդինատն ինքը ցուցակ է)։\nՑուցակներում, ինչպես նաև համասեռ վեկտորներում, հնարավոր է դրանում առկա արժեքներին անուններ տալ\n\nx &lt;- list(b = 1, a = \"a\", c = TRUE, e = 1+4i)\nx\n\n$b\n[1] 1\n\n$a\n[1] \"a\"\n\n$c\n[1] TRUE\n\n$e\n[1] 1+4i\n\n\nԱյս դեպքում դիտելով այս ցուցակի հատկանիշները մենք նկատում ենք, որ անունները \\((names)\\) հայտնվել է հատկանիշների մեջ\n\nattributes(x)\n\n$names\n[1] \"b\" \"a\" \"c\" \"e\"\n\n\nՍա նշանակում է, որ \\(names()\\) ֆունկցիան կարող ենք կիրառել մեր ստեղծած ցուցակի վրա և ստանալ նրանում պահվող արժեքների անունները՝\n\nnames(x)\n\n[1] \"b\" \"a\" \"c\" \"e\"\n\n\n\n\n2.2.11 Ֆակտորներ (Factors)\nֆակտորները ևս վեկտորների տարատեսակ են։ Դրանք նախատեսված են կատեգորիաների վերլուծություն կատարելու համար՝ վիճակագրական մոդելավորման մեջ։ Ֆակտորում իրարից տարբեր արժեքները առանձին պահվում են որպես հատկանիշ և կոչվում են պիտակ՝ (label)։ Ֆակտորները լինում են կարգավորված և ոչ կարգավորված։ Ֆակտորի ամենապարզ օրինակը է 0 և 1-երից կազմված վեկտոր որտեղ 0-ն ունենա Female (կին), իսկ 1-ը՝ Male (տղամարդ) պիտակը։\nՖակտորները կարող են ստեղծվել \\(factor()\\) ֆունկցիայի միջոցով, տալով նրան որպես արգումենտ համասեռ վեկտոր՝ տեքստային տեսակի,\n\nx &lt;- factor(c(\"yes\", \"yes\", \"no\", \"yes\", \"yes\", \"no\"))\nclass(x)\n\n[1] \"factor\"\n\nx\n\n[1] yes yes no  yes yes no \nLevels: no yes\n\nattributes(x)\n\n$levels\n[1] \"no\"  \"yes\"\n\n$class\n[1] \"factor\"\n\nlevels(x)\n\n[1] \"no\"  \"yes\"\n\n\nԻնչպես տեսնում եք վերևում՝ պիտակների կարգը որոշվում է այբբենական դասավորությամբ։ Եթե կարիք կա փոխել ֆակտորում պիտակների դասավորման կարգը, ապա պիտակները կարելի է նախապես հայտարարել՝ ֆակտորը ստեղծելիս\n\nx &lt;- factor(c(\"yes\", \"yes\", \"no\", \"yes\", \"yes\", \"no\"), levels = c(\"yes\", \"no\"))\nx\n\n[1] yes yes no  yes yes no \nLevels: yes no\n\n\nՖակտորները կարող են հեշտացնել տվյալների հետ աշխատանքը։ Օրինակ, եթե տրված է մեծ վեկտոր, որոմ գրված են 0, 1 արժեքները և պետք է կատարել արժեքների փոփոխություն՝ 0 = FEMALE, 1 = MALE,\n\nx &lt;- c(rep(0,10), rep(1,10))\nx\n\n [1] 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1\n\nlevels(x)\n\nNULL\n\nlevels(x) &lt;- c(\"Male\", \"Female\")\nx\n\n [1] 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1\nattr(,\"levels\")\n[1] \"Male\"   \"Female\"\n\n\nՖակտորների հետ թվաբանական գործողություններ հնարավոր չէ անել անգամ երբ դրանում թվային արժեքներ են պահված։ Ֆակտորը թվային վեկտորի վերածելիս պետք է ուշադրություն դարձնել հետևյալ կարևոր առանձնահատկությանը: Դիտարկենք հետևյալ օրինակը՝\n\nx &lt;- rep(c(0,4), times = 10)\nx &lt;- factor(x)\nx\n\n [1] 0 4 0 4 0 4 0 4 0 4 0 4 0 4 0 4 0 4 0 4\nLevels: 0 4\n\n\nՓորձենք նշված ֆակտորը վերածել թվային, համասեռ վեկտորի՝\n\nas.numeric(x)\n\n [1] 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2\n\n\nՊարզապես տեղի է ունեցել պիտակների համարակալում և արժեքների փոխարինում իրենց պիտակներով։ Թվային արժեքները պահպանելու համար պետք է հետևյալ կերպ վարվել՝\n\nas.numeric(as.character(x))\n\n [1] 0 4 0 4 0 4 0 4 0 4 0 4 0 4 0 4 0 4 0 4\n\n\nՊիտակները նաև օգտակար են այն դեպքերում երբ հնարավոր արժեքները գիտենք, բայց այդ արժեքներից որոշները տվյալներում առկա չեն։ Օրինակ, սեռը երկու հնարավոր արժեք ունի, բայց հնարավոր է որոշ դեպքում հավաքագրված տվյալները պարունակեն միայն արական սեռը ցույց տվող արժեքներ։ Այս դեպքում նպատակահարմար է բոլոր հնարավոր արժեքները պահել որպես պիտակներ՝\n\nx &lt;- factor(c(\"M\", \"M\", \"M\", \"M\"), levels = c(\"M\", \"F\"))\nx\n\n[1] M M M M\nLevels: M F\n\n\nՕրինակ \\(table()\\) ֆունկցիան հաշվում է իրարից տարբեր արժեքների կրկնումների քանակները վեկտորում։ Հետևաբար, երբ հնարավոր արժեքներից մեկը ներկայացված չէ տվյալներում, ապա միևնույնն է նպատակահարմար է այն ընդգրկել վերջնական հաշվարկում՝ 0 քանակով՝\n\ntable(c(\"M\", \"M\", \"M\", \"M\"))\n\n\nM \n4 \n\ntable(x)\n\nx\nM F \n4 0 \n\n\n\n\n2.2.12 Ուղղանկյունաձև տվյալների կառուցվածք (Data Frames)\nՏվյալների պահպանման հաջորդ կառուցվածքը ուղղանկյունաձև կառուցվածքն է՝ Data Frame, որի մեջ պահվում են աղյուսակային տվյալները։ Այն ստեղծելու համար օգտագործվում է data.frame() ֆունկցիան։ Այս կառուցվածքը շատ նման է մատրիցներին, մեկ կարևոր տարբերությամբ, որ եթե մատրիցում բոլոր տարրերը պետք է նույն տեսակն ունենային, ապա ուղղանկյունաձև կառուցվածքում յուրաքանչյուր սյուն կարող է տարբեր տեսակի լինել, բայց սյունի ներսում պետք է նույն տեսակի արժեքները պահպանվեն։ Բնականաբար նաև սյուները պետք է միևնույն երկարությունն ունենան։ Այլ կերպ ասած՝ ուղղանկյունաձև կառուցվածքում սյուները միևնույն երկարություն ունեցող համասեռ վեկտորներ են՝ ընդհանուր դեպքում տարբեր տեսակների։\nՈւղղանկյունաձև կառուցվածքն ունի հատուկ հատկանիշ՝ row.names, որը տողերի անուններն են և կարող են ստացվել row.names() ֆունկցիայի կանչմամբ, ինչպես նաև սյուների անուններ, որոնք կարող ենք ստանալ names() ֆունկցիայի միջոցով։\nԴիտարկենք հետևյալ օրինակը, որում ստեղծվում է տվյալների ուղղանկյունաձև կառուցվածք՝\n\nd &lt;- data.frame(subjects = 1:3, status = c(TRUE, TRUE, FALSE))\nd\n\n  subjects status\n1        1   TRUE\n2        2   TRUE\n3        3  FALSE\n\nattributes(d)\n\n$names\n[1] \"subjects\" \"status\"  \n\n$class\n[1] \"data.frame\"\n\n$row.names\n[1] 1 2 3\n\nnrow(d)\n\n[1] 3\n\nncol(d)\n\n[1] 2\n\ndim(d)\n\n[1] 3 2\n\n\nԸնդգծենք, կարևոր առանձնահատկություն՝ հնարավոր է անուններ տալ նաև մատրիցների սյուներին և տողերին, բայց տողերի և սյուների անունները չեն հանդիսանում մատրիցային կառուցվածքի հատկանիշ, այն է՝ դրանք չեն ստեղծվում կառուցվածքի ստեղծման հետ մեկտեղ (մատրիցի դեպքում դրանք կոչվում են dimnames հատկանիշ, այսինքն՝ չափողականության անուններ):\n\nm &lt;- matrix(1:12, ncol = 3, byrow = TRUE)\nrow.names(m) &lt;- nrow(m):1\ncolnames(m) &lt;- c(\"a\", \"b\", \"c\")\nattributes(m)\n\n$dim\n[1] 4 3\n\n$dimnames\n$dimnames[[1]]\n[1] \"4\" \"3\" \"2\" \"1\"\n\n$dimnames[[2]]\n[1] \"a\" \"b\" \"c\"\n\nm\n\n   a  b  c\n4  1  2  3\n3  4  5  6\n2  7  8  9\n1 10 11 12\n\n\nԻսկ ուղղակյունաձև կառուցվածքի ստեղծման հետ մեկտեղ ստեղծվում են դրա տողերի և սյուների անուններ հատկանիշները\n\nd &lt;- data.frame()\nd\n\ndata frame with 0 columns and 0 rows\n\nattributes(d)\n\n$names\ncharacter(0)\n\n$row.names\ninteger(0)\n\n$class\n[1] \"data.frame\"\n\n\n\n\n2.2.13 Ենթակառուցվածքներ (Subsetting)\nԱյստեղ ամփոփելու ենք -ի տվյալների կառուցվածքներից ենթակառուցվածքներ ստանալու հնարավորությունները։ Ինչպես նշվեց վերևում՝ համասեռ վեկտորից հնարավոր է ենթավեկտոր ստանալ [ գործողության միջոցով՝ 4 ձևով։ Իսկ ենթակառուցվածք ստանալու գործողությունները 3-ն են՝ [, [[, $.\n\n[ գործողության կարևորագույն առանձնահատկությունն է, որ այն միշտ վերադարձնում է նույն տեսակի կառուցվածք ինչ սկզբնական կառուցվածքն է։ Օրինակ, եթե դրա միջոցով ենթակառուցվածք ենք ստանում ցուցակից, ապա ստացված կառուցվածքը ևս ցուցակ է։\n\n\nl &lt;- list(a = data.frame(x = letters[1:4], y = seq(2, 3, length.out = 4)),\n        b = list(pi, 3.5, 4), c = matrix(1:6, ncol = 3))\nlength(l)\n\n[1] 3\n\nl\n\n$a\n  x        y\n1 a 2.000000\n2 b 2.333333\n3 c 2.666667\n4 d 3.000000\n\n$b\n$b[[1]]\n[1] 3.141593\n\n$b[[2]]\n[1] 3.5\n\n$b[[3]]\n[1] 4\n\n\n$c\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n\nԱյս ցուցակի առաջին ենթաօբյեկտը ուղղանկյուն-տվյալ է, բայց երբ փորձում ենք դրան դիմել [ գործողության միջոցով, ապա արդյունքը ստացվում է ցուցակ, որովհետև սկզբնական կառուցվածքը ցուցակ էր։\n\nl[1]\n\n$a\n  x        y\n1 a 2.000000\n2 b 2.333333\n3 c 2.666667\n4 d 3.000000\n\nclass(l[1])\n\n[1] \"list\"\n\n\n[ գործողության մյուս առանձնահատկությունն է, որ դրա միջոցով հնարավոր է դիմել կառուցվածքի մի քանի ենթաօբյեկտներին միաժամանակ՝\n\nl[c(1, 3)]\n\n$a\n  x        y\n1 a 2.000000\n2 b 2.333333\n3 c 2.666667\n4 d 3.000000\n\n$c\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n\n\nԵնթակառուցվածք ստանալու հաջորդ գործողությունն է [[։ Սրա միջոցով հնարավոր է դիմել կառուցվածքի միայն մեկ ենթաօբյեկտին և վերադարձվող ենթակառուցվածքի տեսակը կարող է չհամապատասխանել սկզբնական կառուցվածքի տեսակին՝\n\n\nclass(l[[1]])\n\n[1] \"data.frame\"\n\nl[[1]]\n\n  x        y\n1 a 2.000000\n2 b 2.333333\n3 c 2.666667\n4 d 3.000000\n\n\n\nԵնթակառուցվածք ստանալու վերջին գործողությունը $ է։ Սա օգտագործվում է, երբ ուզում ենք կառուցվածքի ենթաօբյեկտներին դիմել անունների միջոցով։ Այս գործողության դեպքում ևս հնարավոր է դիմել միայն մեկ ենթաօբյեկտի և վերադարձվող տեսակը կարող է չհամապատասխանել սկզբնական կառուցվածքի տեսակին։\n\n\nclass(l$a)\n\n[1] \"data.frame\"\n\nl$a\n\n  x        y\n1 a 2.000000\n2 b 2.333333\n3 c 2.666667\n4 d 3.000000\n\n\nՆախորդ երկու գործողությունների դեպքում ևս հնարավոր էր ենթակառուցվածք ստանալ օգտագործելով ենթաօբյեկտի անունը (դեռ ավելին՝ [-ի դեպքում հնարավոր էր նաև մի քանի անունների դիմել), բայց այս վերջինն իրենից ներկայացնում է ավելի կարճ գրելաձև։\n\nl[\"a\"]\n\n$a\n  x        y\n1 a 2.000000\n2 b 2.333333\n3 c 2.666667\n4 d 3.000000\n\nl[[\"a\"]]\n\n  x        y\n1 a 2.000000\n2 b 2.333333\n3 c 2.666667\n4 d 3.000000\n\nl[c(\"b\", \"c\")]\n\n$b\n$b[[1]]\n[1] 3.141593\n\n$b[[2]]\n[1] 3.5\n\n$b[[3]]\n[1] 4\n\n\n$c\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n\n$ գործողությունն ունի մեկ սահմանափակում՝ դրան անուն փոխանցելիս չենք կարող օգտվել փոփոխականներից, այսինքն՝\n\nname &lt;- \"a\"\nl[name]\n\n$a\n  x        y\n1 a 2.000000\n2 b 2.333333\n3 c 2.666667\n4 d 3.000000\n\nl[[name]]\n\n  x        y\n1 a 2.000000\n2 b 2.333333\n3 c 2.666667\n4 d 3.000000\n\nl$name\n\nNULL\n\n\nԱռաջին երկուսը վերադարձնում են անհրաժեշտ ենթաօբյեկտը, բայց վերջինը՝ ոչ, քանի որ $ գործողությանը պետք է փոխանցել անուն և ոչ թե անուն պարունակող փոփոխական։\nՆշենք ևս մեկ կարևոր առանձնահատկության մասին։ $ նշանով ենթակառուցվածք ստանալիս կարելի է ենթաօբյեկտի անունը կիսատ գրել և տեղի կունենա մասնակի համապատասխանեցում՝ partial matching և կգտնվի համապատասխան անունով ենթաօբյեկտը՝\n\nL &lt;- list(asassdrfsas = 1:10, b = 15)\nL$a\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nL[[\"a\"]]\n\nNULL\n\nL[\"a\"]\n\n$&lt;NA&gt;\nNULL\n\n\n[[ գործողության դեպքում կարելի է ստանալ նույն արդյունքը՝ համապատասխան արգումենտի արժեքը FALSE-ի փոխելով՝\n\nL[[\"a\", exact = FALSE]]\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nԵնթակառուցվածք ստանալու գործողությունները կարելի է կիրառել նաև հաջորդաբար։\n\nl[[2]]\n\n[[1]]\n[1] 3.141593\n\n[[2]]\n[1] 3.5\n\n[[3]]\n[1] 4\n\nl[[2]][[1]]\n\n[1] 3.141593\n\nl$a\n\n  x        y\n1 a 2.000000\n2 b 2.333333\n3 c 2.666667\n4 d 3.000000\n\nl$a$y\n\n[1] 2.000000 2.333333 2.666667 3.000000\n\nl$a$y[3]\n\n[1] 2.666667\n\n\n\n2.2.13.1 Ենթամատրից (Subsetting Matrices)\nՄատրիցից ենթամատրից ստանալիս նույնպես կարող ենք վարվել ինչպես ենթավեկտոր ստանալիս՝\n\nx &lt;- matrix(1:24, ncol = 6)\nx\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    1    5    9   13   17   21\n[2,]    2    6   10   14   18   22\n[3,]    3    7   11   15   19   23\n[4,]    4    8   12   16   20   24\n\nx[1]\n\n[1] 1\n\nx[3]\n\n[1] 3\n\n\nԲայց ավելի հարմար է մատրիցի էլեմենտները հանել կրկնակի՝ տողի և սյան համարներով: Առաջին համարը ցույց է տալիս տողը որտեղ գտնվում է հետաքրքրող էլեմենտը, իսկ երկրորդը՝ սյունը։\n\nx\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    1    5    9   13   17   21\n[2,]    2    6   10   14   18   22\n[3,]    3    7   11   15   19   23\n[4,]    4    8   12   16   20   24\n\nx[1, 2]\n\n[1] 5\n\nx[1:2, c(3, 5, 6)]\n\n     [,1] [,2] [,3]\n[1,]    9   17   21\n[2,]   10   18   22\n\n\nՎերջին գործողության ժամանակ մենք նշել ենք երկու տողի և երեք սյուների համարներ։ Վերադարձվել են \\(2\\times 3\\) էլեմենտներ՝ այդ երկու տողի և երեք սյան հատման կետերում հայտնված էլեմենտներից կազմված ենթամատրիցը՝\n\n\n\nԵնթամատրից\n\n\nՀնարավոր է նաև ենթամատրից ստանալիս վերադարձնել բոլոր տողերը կամ բոլոր սյուները՝ դատարկ թողնելով համապատասխան համարի տեղը՝\n\nx[, c(1, 4)]\n\n     [,1] [,2]\n[1,]    1   13\n[2,]    2   14\n[3,]    3   15\n[4,]    4   16\n\nx[c(3, 2), ]\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    3    7   11   15   19   23\n[2,]    2    6   10   14   18   22\n\nx[c(2, 3, 2), ]\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    2    6   10   14   18   22\n[2,]    3    7   11   15   19   23\n[3,]    2    6   10   14   18   22\n\n\nՈւշադրություն դարձրեք, որ հնարավոր է տողերը կամ սյուները ընտրել մատրիցում իրենց հերթականությանը հակառակ, կամ էլ՝ որոշ տողեր և սյուներ մի քանի անգամ։\nԴատարկ թողնելով միաժամանակ և՛ սյուների համարների տեղը, և՛ տողերի կվերադարձնենք ամբողջ մատրիցը։ Սա նույնն է թե ընդհանրապես ենթամատրիցի գործողությունը չկիրառելը, սակայն այս գործողությունը թույլ է տալիս միաժամանակ փոխարինել մատրիցի բոլոր էլեմենտները՝\n\nx\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    1    5    9   13   17   21\n[2,]    2    6   10   14   18   22\n[3,]    3    7   11   15   19   23\n[4,]    4    8   12   16   20   24\n\nx[,]\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    1    5    9   13   17   21\n[2,]    2    6   10   14   18   22\n[3,]    3    7   11   15   19   23\n[4,]    4    8   12   16   20   24\n\nx[,] &lt;- 0 #x &lt;- 0 will delete the matrix and create a new variable equal to 0\nx \n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    0    0    0    0    0    0\n[2,]    0    0    0    0    0    0\n[3,]    0    0    0    0    0    0\n[4,]    0    0    0    0    0    0\n\n\nԻ տարբերություն համասեռ վեկտորների, որտեղ վեկտորի երկարությունից մեծ համարով կոորդինատը կանչելու դեպքում պարզապես անհայտ արժեքն էր վերադարձվում, երկու համարների միջոցով մատրիցի էլեմենտ կանչելիս տողերի կամ սյուների քանակները գերազանցող համար կանչելու դեպքում տեղի կունենա սխալ՝\n\nx &lt;- matrix(1:4, ncol = 2)\nx\nx[1, 3]\n\n\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n\n[1] \"Error in x[1, 3] : subscript out of bounds\\n\"\n\n\n\n\n2.2.13.2 Ենթակառուցվածք ուղղանկյուն-տվյալներից (Subsetting a Data Frame)\nՈւղղանկյուն-տվյալների դեպքում ենթակառուցվածք ստանալու ձևերն ամենաբազմազանն են, քանի որ բոլոր նշված մեթոդները կիրառելի են։\nՕգտագործենք data.frame() ֆունկցիան՝ ուղղանկյուն-տվյալ ստեղծելու համար։\n\ndf &lt;- data.frame(x = letters[1:10], y = seq(pi, 4, length.out = 10))\ndf\n\n   x        y\n1  a 3.141593\n2  b 3.236971\n3  c 3.332350\n4  d 3.427728\n5  e 3.523107\n6  f 3.618486\n7  g 3.713864\n8  h 3.809243\n9  i 3.904621\n10 j 4.000000\n\ndf$x\n\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\"\n\n\nԵնթակառուցվածք ստանալու գործողությունների միջոցով հնարավոր է նաև նոր սյուններ ավելացնել տրված ուղղանկյուն-տվյալին, ինչպես նաև հեռացնել՝\n\ndf[\"New\"] &lt;- 1:nrow(df)\ndf$one &lt;- 1\ndf\n\n   x        y New one\n1  a 3.141593   1   1\n2  b 3.236971   2   1\n3  c 3.332350   3   1\n4  d 3.427728   4   1\n5  e 3.523107   5   1\n6  f 3.618486   6   1\n7  g 3.713864   7   1\n8  h 3.809243   8   1\n9  i 3.904621   9   1\n10 j 4.000000  10   1\n\n\n\ndf$New &lt;- NULL\ndf[\"one\"] &lt;- NULL\ndf\n\n   x        y\n1  a 3.141593\n2  b 3.236971\n3  c 3.332350\n4  d 3.427728\n5  e 3.523107\n6  f 3.618486\n7  g 3.713864\n8  h 3.809243\n9  i 3.904621\n10 j 4.000000\n\n\nNULL-ը հատուկ արժեք է, որը ցույց է տալիս արժեքների գոյություն չունենալը։\nՀեռացնենք մինչ d-ն հանդիպող տառերը պարունակող բոլոր տողերը, կամ, որ նույնն է, պահենք d-ից հետո եկող տառերը պարունակող բոլոր տողերը՝\n\ndf &lt;- df[df$x &gt;= \"d\", ]\ndf\n\n   x        y\n4  d 3.427728\n5  e 3.523107\n6  f 3.618486\n7  g 3.713864\n8  h 3.809243\n9  i 3.904621\n10 j 4.000000\n\n\nԻնչպես տեսնում եք ձախ կողմում պահվել է տողերի հին համարակալումը։ Տողերի համարները գտնելու համար օգտագործենք row.names() ֆունկցիան՝\n\nrow.names(df)\n\n[1] \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\"\n\n\nԱյս ֆունկցիայի միջոցով կարող ենք ինչպես ջնջել տողերի համարակալումը (իրականում այս դեպքում տեղի կունենա միայն վերահամարակալում սկսած 1-ից), կամ տողերին տալ ցանկացած անուններ՝\n\nrow.names(df) &lt;- NULL\ndf\n\n  x        y\n1 d 3.427728\n2 e 3.523107\n3 f 3.618486\n4 g 3.713864\n5 h 3.809243\n6 i 3.904621\n7 j 4.000000\n\nrow.names(df) &lt;- LETTERS[11:(10+nrow(df))]\ndf\n\n  x        y\nK d 3.427728\nL e 3.523107\nM f 3.618486\nN g 3.713864\nO h 3.809243\nP i 3.904621\nQ j 4.000000\n\n\nՀանենք նաև g տառին համապատասխան y արժեքը, ապա P տողում գրված տողն ամբողջությամբ, իսկ վերջում՝ երկրորդ սյունն ամբողջությամբ՝\n\ndf[df$x == \"g\", \"y\"]\n\n[1] 3.713864\n\ndf[\"P\", ]\n\n  x        y\nP i 3.904621\n\ndf[, 2]\n\n[1] 3.427728 3.523107 3.618486 3.713864 3.809243 3.904621 4.000000\n\n#or\ndf[, -1]\n\n[1] 3.427728 3.523107 3.618486 3.713864 3.809243 3.904621 4.000000\n\n\nՎերջին երկու դեպքում -ը տեսնելով որ վերադարձվում է ընդամենը մեկ սյուն, այն վերածեց համասեռ վեկտորի, այսինքն՝ կորցրեց չափողականություն հատկանիշը։ Այս գործողությունից խուսափելու համար կարող ենք օգտագործել հետևյալ կանչը՝\n\ndf[, 2, drop = FALSE]\n\n         y\nK 3.427728\nL 3.523107\nM 3.618486\nN 3.713864\nO 3.809243\nP 3.904621\nQ 4.000000\n\n#or\ndf[, -1, drop = FALSE]\n\n         y\nK 3.427728\nL 3.523107\nM 3.618486\nN 3.713864\nO 3.809243\nP 3.904621\nQ 4.000000\n\n\nԻնչպես տեսնում եք՝ քառակուսի փակագծերում տողերի և սյուների համար նախատեսված տեղերում (ստորակետից համապատասխանաբար ձախ և աջ) հնարավոր է գրել ինչպես տողերի և սյուների համարները՝ դրական և բացասական, այնպես և դրանց անունները, ինչպես նաև տրամաբանական գործողություններ։\n\n\n2.2.13.3 subset() և transform() ֆունկցիաները\nԵնթաքկառուցվածք ստանալու հաջորդ ձևը subset() ֆունկցիան օգտագործելն է։ Դիտարկենք թե այն ինչպես է աշխատում տարբեր տեսակի տվյալների դեպքում։\n\nՄատրիցներ։ Դիտարկենք հետևյալ մատրիցը՝\n\n\nM &lt;- matrix(1:20, nrow = 5)\nM\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    6   11   16\n[2,]    2    7   12   17\n[3,]    3    8   13   18\n[4,]    4    9   14   19\n[5,]    5   10   15   20\n\n\nՀանենք այն տողերը, որոնց առաջին սյան արժեքը մեծ է 5-ից՝\n\nsubset(x = M, subset = M[, 1] &gt; 5)\n\n     [,1] [,2] [,3] [,4]\n\n\n\n\n\n2.2.14 Կառուցվածքի փոփոխություն\nԻնչպես և տեսակների դեպքում էր հնարավոր կատարել փոխարկում՝ ինչպես բացահայտ այնպես և քողարկված, կառուցվածքները ևս հնարավոր է փոխարկել մեկը մյուսին։ Վերը նշված բոլոր կառուցվածքների համար կան դրանց փոխարկող համապատասխան ֆունկցիաները՝ as.vector(), as.factor(), as.matrix(), as.list(), as.data.frame() և հատուկ ուղղանկյուն-տվյալը մատրիցի փոխարկող data.matrix() ֆունկցիան։ Դիտարկենք սրանցից մի քանիսը։\nՆորից դիտարկենք հետևյալ ցուցակը՝\n\nl &lt;- list(a = data.frame(x = letters[1:4], y = seq(2, 3, length.out = 4)),\n        b = list(pi, 3.5, 4), c = matrix(1:6, ncol = 3))\n\nԻնչպես նշվեց՝ [ փակագծի միջոցով ենթակառուցվածք ստանալիս վերադարձնում է նույն տեսակի կառուցվածք ինչ սկզբնական կառուցվածքն է՝\n\nl[1]\n\n$a\n  x        y\n1 a 2.000000\n2 b 2.333333\n3 c 2.666667\n4 d 3.000000\n\n\nԻնչպես տեսնում ենք այս ցուցակը հեշտությամբ կարելի է ուղղանկյուն-տվյալի վերածել, հետևաբար կարող ենք օգտագործել as.data.frame() ֆունկցիան և կատարել նշված փոխարկումը՝\n\ndf1 &lt;- as.data.frame(l[1])\ndf1\n\n  a.x      a.y\n1   a 2.000000\n2   b 2.333333\n3   c 2.666667\n4   d 3.000000\n\n\nԻնչպես նշվել է՝ ցուցակների և ուղղանկյուն-տվյալների հիմնական տարբերությունն է, որ ցուցակները կարող են պահել տարբեր երկարությամբ վեկտորներ։ Օրինակ, դիտարկենք երկու համասեռ վեկտոր որոնցից մեկը պահում է ուսանողների անունները, իսկ մյուսը պահում է գնահատականներ՝\n\nstudents &lt;- c(\"George Sr.\", \"Bill\", \"George\", \"Barack\", \"Donald\")\ngrades &lt;- c(12, 34, 54, 65)\nlength(students)\n\n[1] 5\n\nlength(grades)\n\n[1] 4\n\n\nԻնչպես տեսնում ենք այս երկուսն ունեն տարբեր երկարություններ և տարբեր տեսակներ, հետևաբար դրանք կարող ենք պահել միայն ցուցակում՝\n\nl &lt;- list(students = students, grades = grades)\n\nՆման ձևով սովորաբար պահվում են իրարից անկախ տվյալները։ Եթե գիտենք, որ տրված գնահատականները համապատասխանում են տրված ուսանողներին, միայն վերջին ուսանողի գնահատականը դեռևս հայտնի չէ, ապա օգտագործելով NA արժեքը հնարավոր է այս երկու վեկտորները բերել նույն երկարության և ցուցակը վերածել ուղղանկյուն-տվյալի՝\n\nl[[2]][5] &lt;- NA\nl\n\n$students\n[1] \"George Sr.\" \"Bill\"       \"George\"     \"Barack\"     \"Donald\"    \n\n$grades\n[1] 12 34 54 65 NA\n\nd &lt;- as.data.frame(l, stringsAsFactors = FALSE)\nd\n\n    students grades\n1 George Sr.     12\n2       Bill     34\n3     George     54\n4     Barack     65\n5     Donald     NA\n\n\nԱյստեղից պարզ է դառնում ուղղանկյուն-տվյալների օգտագործման մեկ կարևոր օրինակ՝ երբ պետք է լինում պահել միևնույն սուբյեկտների (մարդկանց, մեքենաների, շենքերի և այլն) վերաբերյալ տարբեր տեսակի տվյալներ, ապա սուբյեկները կարող են լինել ուղղանկյուն-տվյալի տողեր, իսկ համապատասխան տվյալների տեսակները՝ սյուներ։ Եթե որևէ սուբյեկտի վերաբերյալ տվյալներից որևէ մեկը բացակայում է, ապա որպեսզի համապատասխան տվյալները պարունակող սյունը չկարճանա, ավելացնում են NA արժեքը։\nՀիմա կատարենք հակառակ գործողությունը՝ ուղղանկյուն-տվյալը վերածենք ցուցակի և հեռացնենք NA պարունակող արժեքը՝\n\nll &lt;- as.list(d)\nll$grades &lt;- ll$grades[!is.na(ll$grades)]\nll\n\n$students\n[1] \"George Sr.\" \"Bill\"       \"George\"     \"Barack\"     \"Donald\"    \n\n$grades\n[1] 12 34 54 65\n\n\nԵթե ուղղանկյունածև կառուցվածքը բաղկացած է միայն նույն տեսակի արժեքներից, ապա այն կարելի է վերածել մատրիցի՝ data.matrix() ֆունկցիայի միջոցով՝\n\nM &lt;- data.frame(a = c(\"4\", \"5\", \"6\", \"7\"), b = 7:4, stringsAsFactors = FALSE)\nM\n\n  a b\n1 4 7\n2 5 6\n3 6 5\n4 7 4\n\nm1 &lt;- data.matrix(M)\nclass(m1)\n\n[1] \"matrix\" \"array\" \n\nm1\n\n     a b\n[1,] 1 7\n[2,] 2 6\n[3,] 3 5\n[4,] 4 4\n\nm2 &lt;- as.matrix(M)\nm2\n\n     a   b  \n[1,] \"4\" \"7\"\n[2,] \"5\" \"6\"\n[3,] \"6\" \"5\"\n[4,] \"7\" \"4\"\n\n\nԻնչպես տեսանք նույնը հնարավոր է անել նաև as.matrix() ֆունկցիայի միջոցով, պարզապես վերջինս տեսակի քողարկված փոփոխություն կատարելիս ստացավ տեքստային մատրից, իսկ առաջինը՝ թվային։\n\n\n2.2.15 Հարցեր\n\nԻ՞նչ կվերադարձնի հետևյալ արտահայտությունը՝\n\n\nTRUE & 3&lt;2\n\nՊատասխան\nԱյստեղ կարևոր է հասկանալ գործողությունների կատարման հերթականությունը։ & նշանն իրականում նախասահմանված ֆունկցիա է, որն ընդունում է որպես արգումենտներ դրա ձախ և աջ կողմերում գրված արտահայտությունները։ Ուշադիր պետք է լինել, որ այն որպես իր երկրորդ արգումենտ ընդունում է իրենից աջ գրված ամբողջ արտահայտությունը, այսինքն՝ ոչ թե միայն 3-ը, այլ՝ \\(3&lt;2\\) ամբողջությամբ՝\n\nTRUE & 3&lt;2\n\n[1] FALSE\n\n#the same as\n`&`(TRUE, 3&lt;2)\n\n[1] FALSE\n\n\n\nԻ՞նչ կվերադարձնի հետևյալ արտահայտությունը՝\n\n\n0 & TRUE&lt;2\n\nՊատասխան\nԱյստեղ նույնպես պետք է հասկանալ որպես ֆունկցիա, որն ընդունում է իր ձախ և աջ կողմերում գրված արժեքները որպես արգումենտներ: Ձախ կողմում գրված է թվային արժեք, իսկ \\(\\&\\) ֆունկցիան ընդունում է որպես արգումենտներ միայն տրամաբանական արժեքներ, հետևաբար տեղի է ունենում արժեքի տեսակի քողարկված փոփոխություն և, ինչպես գիտենք, 0-ն փոխվում է FALSE-ի։ Աջ կողմում ևս տեղի է ունենում արժեքի փոփոխություն։ Թվային համեմատություն կատարելու համար TRUE արժեքը փոխվում է 1-ի և համեմատվում 2-ի հետ։\n\n`&`(0, TRUE&lt;2)\n\n[1] FALSE\n\n\n\nԻ՞նչ կվերադարձնի հետևյալ արտահայտությունը՝\n\n\nx &lt;- 5!=5\n!x+1\n\nՊատասխան\n! նշանը ֆունկցիա է, որը որպես իր արգումենտ ընդունում է իրենից աջ գրված ամբողջ արտահայտությունը։ Այստեղ կարող է տպավորություն ստեղծվել, որ ! կիրառված է միայն x-ի վրա, բայց իրականում այն կիրառված է ամբողջ աջ մասի վրա, հետևաբար նախ պետք է կատարել գումարման գործողությունը, ապա՝ կիրառել ժխտման գործողությունը՝\n\nx &lt;- 5!=5\nx\n\n[1] FALSE\n\n`!`(x+1) # !x+1\n\n[1] FALSE\n\n# the same as\n!(x+1)\n\n[1] FALSE\n\n# NOT the same as\n(!x)+1\n\n[1] 2\n\n\n\nԻ՞նչ կվերադարձնի հետևյալ արտահայտությունը՝\n\n\nx &lt;- matrix(1:4, nrow = 2, byrow = TRUE)\nx &gt; c(1,2)\n\nՊատասխան\nՔանի որ համեմատության մեջ գտնվող երկրորդ վեկտորն ավելի կարճ է քան մատրիցը (մատրիցի երկարությունը հավասար է իր տարրերի քանակին), ապա վեկտորը կրկնվում է այնքան անգամ մինչև դրա երկարությունը հավասարվի մատրիցի երկարությանը։ Այստեղ վեկտորը կրկնվելով ևս մեկ անգամ կստանանք ճշգրիտ մատրիցի երկարությունը, դրա համար ծրագրի կողմից զգուշացում չի տրվի։ Երբ վեկտորի երկարությունը հավասարվում է մատրիցի երկարությանը, ապա վեկտորը վերածվում է մատրիցի՝ տարրերի տեղաբաշխումը կատարելով սյուներով (byrow = FALSE), քանի որ այդպիսինն է matrix() ֆունկցիայի լռելյալ վարքագիծը, և օգտագործելով առաջին մատրիցի տողերի քանակը։ Այս ամբողջից հետո կկատարվի համեմատությունը։\n\nx &lt;- matrix(1:4, nrow = 2, byrow = TRUE)\nx\n\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n\nmatrix(rep(1:2, times = 2), nrow = 2, byrow = FALSE)\n\n     [,1] [,2]\n[1,]    1    1\n[2,]    2    2\n\nx &gt; matrix(rep(1:2, times = 2), nrow = 2, byrow = FALSE)\n\n      [,1] [,2]\n[1,] FALSE TRUE\n[2,]  TRUE TRUE\n\n# the same as\nx &gt; c(1,2)\n\n      [,1] [,2]\n[1,] FALSE TRUE\n[2,]  TRUE TRUE\n\n\n\n\n2.2.16 Խնդիրներ\n\nՏրված է հետևյալ համասեռ վեկտորը՝\n\n\na &lt;- c(3, 4, 3, 2, 1, -1, 6, -1, -2)\n\nԼուծել հավասարումների հետևյալ համակարգը՝\n\\[\n\\left\\{\n\\begin{matrix}\n&3x_1+4x_2+3x_3=6\\\\\n&2x_1+x_2-x_3=10\\\\\n&6x_1-x_2-2x_3=-4\n\\end{matrix}\\right.\n\\]\nԼուծումները ներկայացնել հարյուրերորդական ճշտությամբ։\nԼուծում\n\na &lt;- c(3, 4, 3, 2, 1, -1, 6, -1, -2)\nb &lt;- c(6, 10, 4)\nA &lt;- matrix(a, byrow = TRUE, nrow=3)\nx &lt;- solve(A)%*%b #or solve(A,b)\nx &lt;- round(x, 2)\nx\n\n      [,1]\n[1,] -0.10\n[2,]  5.27\n[3,] -4.93\n\n\n\nՍտեղծեք հետևյալ համասեռ վեկտորները՝\n\n\nContinents &lt;- c(\"Europe\", \"Australia\", \"Asia\", \n              \"America\", \"Africa\", \"Antarctica\")\n\nx &lt;- c(USA = 120, Europe = 320, Australia = 360, Japan = 450, \n     Asia = 680, America = 200, France = 80, Armenia = 600, Africa = 250)\nx\n\n      USA    Europe Australia     Japan      Asia   America    France   Armenia \n      120       320       360       450       680       200        80       600 \n   Africa \n      250 \n\n\nՄայրցամաքների համար, որոնց արժեքը չի գերազանցում 350-ը, մեծացրեք արժեքները 50%-ով։ Փոփոխությունները կատարեք տրված համասեռ x վեկտորի մեջ։ Հանեք փոփոխված արժեքները իրենց մայրցամաքների անունների հետ և պահեք այդ տվյալները z վեկտորում։\nԼուծում\n\ny &lt;- names(x) %in% Continents & x &lt;= 350\nx[y] &lt;- x[y]*1.5\n\nz &lt;- x[y]\nz\n\n Europe America  Africa \n    480     300     375 \n\n\n\nՍտեղծեք հետևյալ համասեռ վեկտորը՝\n\n\nset.seed(1)\nn &lt;- 100\nX &lt;- c(sample(c(NaN, NA, 1), replace = TRUE, size = n), rep(\"a\", n))\nX[1:10]\n\n [1] \"NaN\" \"1\"   \"NaN\" NA    \"NaN\" \"1\"   \"1\"   NA    NA    \"1\"  \n\n\nՀաշվեք NA-ների քանակը (ճշգրիտ NA-ների), ինչպես նաև NaN-երի քանակը։\nԼուծում\nՔանի որ համասեռ վեկտորում ներառված են նաև տառեր, ապա այդ վեկտորի տեսակը տեքստային է, այսինքն՝ թվային արժեքների տեսակի քողարկված փոփոխություն է տեղի ունեցել և դրանք վերածվել են տեքստի, հետևաբար NaN-երը նույնպես տեքստի են վերածվել։ Այն թվերի վերածելու համար պետք է հեռացնենք տառերը։ Տրված վեկտորից ստանանք ենթավեկտոր, որը կպարունակի միայն NaN տեքստային արժեքները (իրականում կմնան նաև NA արժեքները, քանի որ -ը չգիտի թե դրանք հավասա՞ր են NaN տեքստային արժեքին, թե՞ ոչ։)\n\nsum(is.na(X)) #number of exact NAs\n\n[1] 37\n\nX &lt;- as.numeric(X[X == \"NaN\"])\nX\n\n [1] NaN NaN  NA NaN  NA  NA NaN NaN NaN  NA  NA  NA  NA NaN NaN NaN NaN NaN  NA\n[20] NaN NaN  NA  NA  NA NaN NaN  NA  NA  NA  NA  NA NaN  NA NaN NaN  NA  NA  NA\n[39]  NA  NA  NA NaN  NA  NA  NA  NA NaN  NA  NA NaN NaN NaN NaN  NA NaN NaN  NA\n[58] NaN NaN NaN NaN  NA NaN NaN  NA  NA  NA  NA  NA NaN\n\nsum(is.nan(X))\n\n[1] 33\n\n\n\nԴիտարկենք airquality ուղղանկյունաձև տվյալները, որում պահվում են Նյու Յորքում մի քանի ամիսների ընթացքում կատարված մթնոլորտային չափումների արդյունքները։ Ստորև գրված հարցերին պատասխանելու համար գրել մեկ տողանոց հրամաններ։\n\n\ndat &lt;- airquality\ndim(dat)\n\n[1] 153   6\n\nhead(dat)\n\n  Ozone Solar.R Wind Temp Month Day\n1    41     190  7.4   67     5   1\n2    36     118  8.0   72     5   2\n3    12     149 12.6   74     5   3\n4    18     313 11.5   62     5   4\n5    NA      NA 14.3   56     5   5\n6    28      NA 14.9   66     5   6\n\n\n\nՍտեղծել նոր սյուն Temp.C, որի մեջ կպահվի ջերմաստիճանը Ցելսիուսի սանդղակով։ Temp սյան մեջ ջերմաստիճանը պահված է Ֆարենհայտի սանղակով: Երկու սանդղակների միջև կապը հետևյալն է՝\n\n\\[C=\\frac59(F-32).\\]\nՏվյալները պահելու համար օգտագործել տասնորդական ճշտությունը։\nՀետագա բոլոր հաշվարկներում օգտագործել Ցելսիուսի ջերմաստիճանը։\nԼուծում\n\ndat$Temp.C &lt;- round((dat$Temp-32)*5/9, digits = 1)\nhead(dat)\n\n  Ozone Solar.R Wind Temp Month Day Temp.C\n1    41     190  7.4   67     5   1   19.4\n2    36     118  8.0   72     5   2   22.2\n3    12     149 12.6   74     5   3   23.3\n4    18     313 11.5   62     5   4   16.7\n5    NA      NA 14.3   56     5   5   13.3\n6    28      NA 14.9   66     5   6   18.9\n\n\n\nՀաշվել մայիս ամսվա միջին ջերմաստիճանը։\n\nԼուծում\n\nmean(dat[dat$Month == 5,\"Temp.C\"])\n\n[1] 18.63226\n\n\n\nԳտնել տարվա ամենաբարձր ջերմաստիճանին համապատասխանող օրը, ամիսը և ջերմաստիճանը (նշված հերթականությամբ)։\n\nԼուծում\n\ndat[dat$Temp.C == max(dat$Temp.C), c(\"Day\", \"Month\", \"Temp.C\")]\n\n    Day Month Temp.C\n120  28     8   36.1\n\n\n\nԴիտարկելով միայն օրերը, երբ Ցելսիուսի ջերմաստիճանը եղել է 30-ից բարձր, հաշվել քամու միջին արագությունը և տպել բոլոր այն օրերը (ամսվա, ջերմաստիճանի և քամու արագության հետ մեկտեղ), երբ քամու արագությունը գերազանցում է այդ օրերի համար հաշված քամու միջին արագությանը։\n\nԼուծում\n\ndat[dat$Temp.C &gt; 30 & dat$Wind &gt; mean(dat[dat$Temp.C &gt; 30, \"Wind\"]),\n    c(\"Day\", \"Month\", \"Temp.C\", \"Wind\")]\n\n    Day Month Temp.C Wind\n40    9     6   32.2 13.8\n41   10     6   30.6 11.5\n42   11     6   33.9 10.9\n43   12     6   33.3  9.2\n71   10     7   31.7  7.4\n75   14     7   32.8 14.9\n89   28     7   31.1  7.4\n100   8     8   32.2 10.3\n101   9     8   32.2  8.0\n102  10     8   33.3  8.6\n120  28     8   36.1  9.7\n128   5     9   30.6  7.4\n\n\n\n\n2.2.17 Ամփոփում\n\nType Coercion\nMissing Values\nSubsetting\nAttributes\nVector, Factor, Matrix, List, Data Frame\nPartial Matching\n\nFunctions\n\nclass()\nlength()\nnchar()\n\nc()\nvector()\nrep()\nseq(); seq_len(); seq_along()\n\nas.logical(); as.integer(); as.numeric(); as.complex(); as.character()\n\nsum(); round(); min(); max(); mean(); sqrt()\n\nwhich()\nnames()\n\nSys.time()\nattributes(); attr()\n\nmatrix()\ndim(); nrow(); ncol()\nrbind(); cbind()\ndet(); solve(); t()\n\nlist()\nfactor(); table()\ndata.frame(); head(); tail()\nrow.names()\n\nas.vector(); as.factor(); as.matrix(); as.data.frame(); data.matrix(); as.list()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R ծրագրավորման միջավայր</span>"
    ]
  },
  {
    "objectID": "rintro.html#control",
    "href": "rintro.html#control",
    "title": "2  R ծրագրավորման միջավայր",
    "section": "2.3 Կարգավորման կառուցվածքներ (Control Structures)",
    "text": "2.3 Կարգավորման կառուցվածքներ (Control Structures)\n\n2.3.1 Տրամաբանություն (Logic)\n\nTRUE & c(TRUE,FALSE,FALSE)\n\n[1]  TRUE FALSE FALSE\n\nTRUE | c(TRUE,FALSE,FALSE)\n\n[1] TRUE TRUE TRUE\n\nTRUE || c(TRUE,FALSE,FALSE)\n\n[1] TRUE\n\n#All AND operators are evaluated before OR operators.\n\n5 &gt; 8 || 6 != 8 && 4 &gt; 3.9\n\n[1] TRUE\n\n#identical(), isTRUE()\n\n\n#exclusive OR. If one argument evaluates to TRUE and one argument evaluates to \n#FALSE, then this function will return TRUE, otherwise it will return FALSE.\nxor(5 == 6, !FALSE)\n\n[1] TRUE\n\n#\nwhich(1:10 &gt; 7)\n\n[1]  8  9 10\n\n#\nints &lt;- c(-1, 2, 10)\nany(ints &lt; 0)\n\n[1] TRUE\n\nall(ints &gt; 0)\n\n[1] FALSE\n\n\n\n\n2.3.2 Գործողությունների իրականացման հերթականության կարգավորում (Control Flow)\nԱյս կառուցվածքի միջոցով կատարվում է արտահայտությունների պայմանական կատարում՝ կախված տրված պայմանի ճշմարտացիությունից։ Եթե տրված պայմանը ճիշտ է, կատարվում է որևէ գործողություն, իսկ եթե սխալ է, այդ գործողությունը չի կատարվում կամ, անհրաժեշտության դեպքում, կատարվում է մեկ այլ գործողություն։ Հնարավոր է նաև տրված պայմանի սխալ լինելու դեպքում ևս մեկ պայման ստուգել ու դրա ճշմարտացիությունից ելնելով կատարել գործողություններ։ Դիտարկենք երկու օրինակ։ (Ուշադրություն դարձրեք, որ else բառը գրված է դրան նախորդող ձևավոր փակագծի հետ մեկ տողում։ Եթե այն գրված լիներ հաջորդ տողում, տեղի կունենար սխալ։)\n\nx &lt;- 4\nif(x &gt; 3){\n  print(\"The value is greater than 3\")\n}  else {\n    print(\"The value is less than or equal to 3\")\n  }\n\n[1] \"The value is greater than 3\"\n\n\n\nx &lt;- 2.5\nif(x &gt; 3){\n  print(\"The value is greater than 3\")\n}  else if(x &gt; 2){\n    print(\"The value is in (2,3]\")\n} else{\n    print(\"The value is less than or equal to 2\")\n  }\n\n[1] \"The value is in (2,3]\"\n\n\nՀնարավոր է նաև այս կառուցվածքի միջոցով կատարել վերագրում՝\n\nx &lt;- 12\ny &lt;- if(x %% 2 == 0){\n  \"A Prime\"\n} else{\n  \"Not a Prime\"\n}\ny\n\n[1] \"A Prime\"\n\n\nIf արտահայտությունում պայման գրելիս պետք է ուշադիր լինել, որ վերադարձվող տրամաբանական արժեքը պարունակվի 1 (և ոչ ավել) երկարությամբ վեկտորում։\n\nx &lt;- 1:2\nx %% 2 == 0\n\n[1] FALSE  TRUE\n\ntry(\n  if(x %% 2 == 0) {x}\n) \n\nError in if (x%%2 == 0) { : the condition has length &gt; 1\n\n\nԲերված օրինակում մենք որպես պայման գրել ենք վեկտոր, որը ոչ թե մեկ այլ երկու տրամաբանական արժեք է վերադարձնում։ Նախկին թողարկումներում -ը վերցնում էր այդ վեկտորի միայն առաջին արժեքը և զգուշացում տալիս։ Ներկայիս թողարկումներում այս վարքագիծը փոփոխության է վերածվել և այժմ -ը սխալ է վերադարձնում։ try() ֆունկցիան հնարավորություն է տալիս ստուգելու, թե արդյոք տրված արտահայտությունը կաշխատի առանց սխալների։\nՔանի որ պայմանի վերադարձրած արժեքի երկարությունը պետք է 1 լինի, ապա վեկտորների հետ աշխատելիս օգտագործվում են կրկնակի նշանները, որոնք հենց վերցնում են միայն վեկտորի առաջին կոորդինատը։ Ստորև գրված երկու ծրագրային իրագործումներից առաջինը սխալ է վերադարձնում, իսկ երկրորդը զգուշացում տալիս՝\n\nx &lt;- c(3, 4)\ny &lt;- c(1, 5)\nif(x &gt; y & TRUE) print(x)\n\n\nx &lt;- c(3, 4)\ny &lt;- c (1, 5)\nif(x &gt; y & TRUE) print(x)\n\nԳոյություն ունի նաև նախասահմանված ֆունկցիա, որը կատարում է այս կառուցվածքի գործառույթները և ավելի հարմար է օգտագործել պարզ պայմանների առկայության դեպքում՝\n\nx &lt;- 12\ny &lt;- ifelse(x%%2 == 0, \"A Prime\", \"Not a Prime\")\ny\n\n[1] \"A Prime\"\n\n\nԱյս ֆունկցիան երբեմն կարող է ավելի օգտակար լինել, քան համապատասխան կառուցվածքը, քանի որ դրանում որպես պայման կարելի է փոխանցել մեկից ավելի երկարություն ունեցող վեկտոր՝\n\nx &lt;- 1:2\ny &lt;- ifelse(x %% 2 == 0, \"A Prime\", \"Not a Prime\")\ny\n\n[1] \"Not a Prime\" \"A Prime\"    \n\n\n\n\n2.3.3 Ամփոփում\n\n`&`; `&&`; `|`; `||`\nidentical()\nisTRUE()\nwhich()\nxor()\nany()\nall()\nifelse()\ntry()\nwarning()\nstop()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R ծրագրավորման միջավայր</span>"
    ]
  },
  {
    "objectID": "rintro.html#loop",
    "href": "rintro.html#loop",
    "title": "2  R ծրագրավորման միջավայր",
    "section": "2.4 Շրջապտույտի կառուցվածքներ (Loop Structures)",
    "text": "2.4 Շրջապտույտի կառուցվածքներ (Loop Structures)\n\n2.4.1 for\nՇրջապտույտի համար նախատեսված for կառուցվածքը վերցնում է կրկնման համար նախատեսված փոփոխականը և դրան հաջորդաբար վերագրում է արժեքներ որևէ հաջորդականությունից (օրինակ՝ վեկտորից)։\n\nfor(i in 1:5){\n  print(i)\n}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n\n\nԱյստեղ կրկնման համար նախատեսված փոփոխականը i-ն է, որը հաջորդաբար ընդունում է 1:5 վեկտորում առկա արժեքները, իսկ կառուցվածքի ներսում, ամեն քայլին կատարվում են որոշակի գործողություններ։ Այս կառուցվածքը կարող է ունենալ տարբեր գրելաձևեր՝ նույն գործողությունը կատարելու համար՝\n\nx &lt;- c(12, 34, 55, 64)\nfor(i in 1:length(x)){\n  print(x[i])\n}\n\n[1] 12\n[1] 34\n[1] 55\n[1] 64\n\n\n\nx &lt;- c(12, 34, 55, 64)\nfor(i in seq_len(length(x))){\n  print(x[i])\n}\n\n[1] 12\n[1] 34\n[1] 55\n[1] 64\n\n\n\nx &lt;- c(12, 34, 55, 64)\nfor(i in seq_along(x)){\n  print(x[i])\n}\n\n[1] 12\n[1] 34\n[1] 55\n[1] 64\n\n\n\nx &lt;- c(12, 34, 55, 64)\nfor(i in x){\n  print(i)\n}\n\n[1] 12\n[1] 34\n[1] 55\n[1] 64\n\n\nՀնարավոր է նաև ներդնել for շրջապտույտի կառուցվածքները՝\n\nx &lt;- matrix(1:4,ncol=2)\nx\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\nfor(i in seq_len(nrow(x))){\n  for(j in seq_len(ncol(x))){\n    print(x[i, j])\n  }\n}\n\n[1] 1\n[1] 3\n[1] 2\n[1] 4\n\n\nՀաճախ սա խնդիրներ լուծելու ոչ ամենաարդյունավետ մեթոդն է, սակայն երբեմն այն միակ կիրառելին է։ Եթե հնարավորություն կա՝ պետք է խուսափել շրջապտույտի ներդրված կառուցվածքներից։ Հետաքրքիր խնդիրներ են շրջապտույտի կառուցվածքով գրված լուծումները վերածել առանց շրջապտույտի կառուցվածքով լուծումների։ Դիտարկենք հետևյալ օրինակը, երբ պետք է մատրիցի բոլոր տարրերը փոխարինել 0-ով՝\n\nx &lt;- matrix(1:4, ncol = 2)\nx\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\nfor(i in seq_len(nrow(x))){\n  for(j in seq_len(ncol(x))){\n    x[i, j] &lt;- 0\n  }\n}\nx\n\n     [,1] [,2]\n[1,]    0    0\n[2,]    0    0\n\n\nՍա հնարավոր է լուծել մեկ տողով` առանց որևէ շրջապտույտի,\n\nx &lt;- matrix(1:4, ncol = 2)\nx\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\nx[ , ] &lt;- 0\nx\n\n     [,1] [,2]\n[1,]    0    0\n[2,]    0    0\n\n\n\n\n2.4.2 while\nՇրջապտույտի մյուս կառուցվածքն է while կառուցվածքը։\n\ni &lt;- 0\nwhile(i &lt; 5){\n  print(i)\n  i &lt;- i + 1\n}\n\n[1] 0\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n\nprint(i)\n\n[1] 5\n\n\nՆախորդի համեմատությամբ կան մի քանի տարբերություններ։ Նախ կրկնման փոփոխականը պետք է սկզբնարժեք ստանա կառուցվածքից դուրս, իսկ կառուցվածքի ներսում դրա արժեքը պետք է փոխվի, քանի որ հակառակ դեպքում տեղի կունենա անվերջ շրջապտույտ։ Այսպիսով՝ այս կառուցվածքն ավելի վտանգավոր է քանի որ ծրագրավորողն ինքը պետք է կարգավորի շրջապտույտի սկիզբը և քայլը, ապահովելու համար շրջապտույտի ավարտը։ Մյուս կողմից էլ դրանք առավելություն ունեն քանի որ հնարավորություն են տալիս միաժամանակ մի քանի պայմաններ ստուգելու։ Դիտարկենք պատահական թափառման հետևյալ օրինակը, երբ շարժվողը դուրս է գալիս որևէ կետից և 0.5 հավանականությամբ մեկ քայլ կատարում աջ կամ ձախ (ուղղությունը կարող է որոշվել, օրինակ, արդար մետաղադրամ նետելով)։ Թափառումն ավարտվում է եթե շարժվողը հասնում է երկու՝ ամեն կողմում մեկական, նպատակներից որևէ մեկին։\n\nz &lt;- 7\nwhile(z &gt;= 0 & z &lt;= 10){\n  if(rbinom(n = 1, size = 1, prob = 0.5) == 1) \n    z &lt;- z + 1\n  else z &lt;- z - 1\n}\nprint(z)\n\n[1] 11\n\n\nՀիշենք, որ տրամաբանական գործողությունները կատարվում են ձախից աջ։\n\n\n2.4.3 repeat, next, break, return\nԿրկնման repeat հրամանը ստեղծում է անվերջ շրջապտույտ, որը կարող է կասեցվել միայն `break`` դադար, հրամանի միջոցով։\n\ni &lt;- 0\nrepeat{\n  i &lt;- i + 1\n  if(i == 5) break\n}\nprint(i)\n\n[1] 5\n\n\nՀրաման next-ն օգտագործվում է շրջապտույտի ժամանակ կրկնվող փոփոխականի որևէ արժեք բաց թողնելու համար։ Ենթադրենք ուզում ենք տպել մինչ 10-ն առկա բոլոր զույգ թվերը՝ բացառությամբ 6-ի և 8-ի՝\n\nfor(i in 1:10){\n  if(i %in% c(6, 8)) next\n  if(i %% 2 == 0) print(i)\n}\n\n[1] 2\n[1] 4\n[1] 10\n\n\nՇրջապտույտը դադարեցնելու համար կարող ենք օգտագործել ինչպես break այնպես և return հրամանները։ Այս վերջինը հաճախ օգտագործվում է ֆունկցիաների սահմանման մեջ, բայց կարող է օգտակար լինել նաև շրջապտույտը դադարեցնելու համար։ Ստորև գրված ծրագիրը գտնում է 20-ից հետո 16-ին բաժանվող առաջին թիվը՝\n\ni &lt;- 20\nwhile(TRUE){\n  if(i %% 16 == 0) return(i)\n  i &lt;- i + 1\n}\ni\n\n[1] 32\n\n\n\n\n2.4.4 Խնդիրներ\n\nԴիտարկենք airquality ուղղանկյունաձև տվյալները, որում պահվում են Նյու Յորքում մի քանի ամիսների ընթացքում կատարված մթնոլորտային չափումների արդյունքները։ Մեր նպատակն է ուսումնասիրել ջերմաստիճանի (Temp) բաշխումը։\n\nՋերմաստիճանի միջակայքը՝ նվազագույնից առավելագույն հատվածը, բաժանում ենք երեք հավասար մասերի և հաշվում յուրաքանչյուր հատվածում ընկնող ջերմաստիճանի չափումների քանակները։ Առանձնացնում ենք այն հատվածը, որն ամենաքիչ քանակով կետերն է պարունակում և airquality կառուցվածքից հեռացնում ենք բոլոր այն տողերը որոնց ջերմաստիճանն ընկնում է այդ հատվածում:\nԼուծում\nՆախ տանք կարճ լուծում, որը, սակայն, դժվար կլինի ընդհանրացնել 3-ից մեծ թվով հատվածների համար։\n\nrm(list = ls())\ndat &lt;- airquality\nx &lt;- \"Temp\"\n\nm &lt;- min(dat[, x])\nM &lt;- max(dat[, x])\nd &lt;- (M - m) / 3\nM1 &lt;- m + d\nM2 &lt;- m + 2 * d\nn1 &lt;- sum(m &lt;= dat[, x] & dat[, x] &lt;= M1)\nn2 &lt;- sum(M1 &lt; dat[, x] & dat[, x] &lt;= M2)\nn3 &lt;- sum(M2 &lt; dat[, x] & dat[, x] &lt;= M)\n\nif(min(c(n1, n2, n3)) == n1){\n  xmin &lt;- m\n  xmax &lt;- M1\n} else if(min(c(n1, n2, n3)) == n2){\n  xmin &lt;- M1\n  xmax &lt;- M2\n} else {\n  xmin &lt;- M2\n  xmax &lt;- M\n}\n\ndat0 &lt;- dat[!(xmin &lt;= dat[, x] & dat[, x] &lt;= xmax), ]\ndim(dat)\n\n[1] 153   6\n\ndim(dat0)\n\n[1] 121   6\n\n\nՀաջորդ լուծումը տրված N-ի համար ջերմաստիճանի միջակայքը բաժանում է N հավասար մասերի և հաշվում յուրաքանչյուր հատվածում ընկած ջերմաստիճանի չափումների քանակները։ Նվազագույն քանակով ջերմաստիճանի չափումներ պարունակող հատվածին համապատասխան օրերը հեռացվում են airquality ուղղանկյուն տվյալներից։\n\nrm(list = ls())\ndat &lt;- airquality\nX &lt;- \"Temp\"\n\nN &lt;- 8\n\nY &lt;- dat[, X]\n\nInt &lt;- seq(min(Y), max(Y), length.out = N+1)\n\n#x &lt;- Y[1]\n\nIndices &lt;- vector()\nfor(x in Y){\n  if(all(Int &lt;= x)) i &lt;- N+1\n  else i &lt;- which(Int &gt; x)[1]\n  Indices &lt;- c(Indices, i) \n}\ntable(Indices)\n\nIndices\n 2  3  4  5  6  7  8  9 \n11 10 15 25 35 30 15 12 \n\ni0 &lt;- as.numeric(names(table(Indices)[table(Indices) == min(table(Indices))]))\ndat0 &lt;- dat[!(Y &gt;= Int[i0 - 1] & Y &lt;= Int[i0]), ]\n\n\n\n2.4.5 Ամփոփում\n\nLoop Structures\n\nFunctions\n\nbase::any(); base::all()\nbase::identical(); base::isTRUE(); base::isFALSE()\nbase::xor()\nbase::ifelse()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R ծրագրավորման միջավայր</span>"
    ]
  },
  {
    "objectID": "rintro.html#functions",
    "href": "rintro.html#functions",
    "title": "2  R ծրագրավորման միջավայր",
    "section": "2.5 Ֆունկցիաներ",
    "text": "2.5 Ֆունկցիաներ\n\n2.5.1 Ֆունկցիայի սահմանումը\nԱյն ամենն ինչ գոյություն ունի -ում օբյեկտ է, այն ամենն ինչ կատարվում է՝ ֆունկցիայի կանչ (Ջոն Չեմբերս)։\n-ում ֆունկցիաները կատարում են նույն դերը ինչ մաթեմատիկայում՝ դրանք համապատասխանություն են ստեղծում օբյեկտների միջև, այն է՝ դուք դրանց փոխանցում եք որևէ օբյեկտ, որը կոչվում է այդ ֆունկցիայի արգումենտ, իսկ այն ձեզ վերադարձնում է մեկ այլ օբյեկտ, որը կոչվում է արժեք։ Հնարավոր են նաև դեպքեր, երբ ֆունկցիան ոչ մի արժեք չի վերադարձնում, պարզապես կանչելիս այն կատարում է որոշակի գործողություն։ Հնարավոր է նաև, որ ֆունկցիան արգումենտներ չունենա, այսինքն՝ գործողություն կատարելու համար կամ արժեք վերադարձնելիս այն օգտագործողի կողմից օբյեկտների ներմուծման կարիք չունի։ Երբ գործողությունների որոշակի շարք անընդհատ օգտագործվում է, ապա նպատակահարմար է դա սահմանել ֆունկցիայի տեսքով և վերաօգտագործման ժամանակ ընդամենը կանչել այդ ֆունկցիան։ Դիտարկենք ֆունկցիայի առաջին օրինակը, որում տրված թվի համար հաշվվում է դրա քառակուսի արմատը։ Սա նման է լինելու նախասահմանված sqrt() ֆունկցիային, միակ տարբերությամբ, որ վերջինս իրական թիվ ստանալու դեպքում իրական թիվ էր վերադարձնում, իսկ մեր ֆունկցիան միշտ կոմպլեքս թիվ է վերադարձնելու։\n\nSqrt &lt;- function(comp){\n  comp &lt;- as.complex(comp)\n  sqrt(comp)\n}\n\nSqrt(-1)\n\n[1] 0+1i\n\n\nԻնչպես տեսնում եք՝ արժեք վերադարձնելու return հրամանն առկա չէ ֆունկցիայի սահմանման մեջ։ Այս դեպքում ամենավերջում գրված արժեքն ինքնաբերաբար վերադարձվում է։ Return հրամանի կիրառումն առավելապես օգտակար է լինում երբ վերադարձվող արժեքը պայմանից է կախված։ Օրինակ, ստորև գրված ֆունկցիան նույնպես հաշվում է տրված թվի արմատը, իսկ բացասական թիվ ստանալու դեպքում այն պարզապես վերադարձնում է հաղորդագրություն, որ նշված թվի արմատը հնարավոր չէ հաշվել՝ ի տարբերություն նախասահմանված sqrt() ֆունկցիայի, որը նման դեպքերում դադարեցնում էր հրամանի ի կատար ածումը։\n\nSqrt_ &lt;- function(x) {\n  if(x &lt; 0) return(\"A Negative number is provided!\")\n  return(sqrt(x))\n}\nSqrt_(-5)\n\n[1] \"A Negative number is provided!\"\n\nSqrt_(5)\n\n[1] 2.236068\n\n\nԻնչպես տեսնում եք՝ if հրամանից հետո else հրամանը գրելու անհրաժեշտություն չկա, քանի որ առաջին հանդիպած return հրամանի իրագործումից հետո ֆունկցիայի գործողությունը դադարեցվում է։\nՑանկացած, այդ թվում և նախասահմանված, ֆունկցիայի կառուցվածքը ստանալու համար պարզապես պետք է տպել դրա անունը՝ առանց արգումենտների համար նախատեսված փակագծերի՝\n\nSqrt\n\nfunction (comp) \n{\n    comp &lt;- as.complex(comp)\n    sqrt(comp)\n}\n\n\nՖունկցիանները կարելի է այնպես սահմանել, որ դրանց որոշ արգումենտներն ունենան լռելյալն արժեքներ, այսինքն՝ հնարավոր լինի ֆունկցիան կանչել առանց այդ արգումենտներին արժեքներ տալու։ Հետևյալ ֆունկցիան վերցնում է երկու արգումենտ և վերադարձնում է առաջին արգումենտը՝ երկրորդ արգումենտով աստիճան բարձրացրած՝\n\nPower &lt;- function(base, exp = 2){\n  return(base^exp)\n}\n\nԵրկրորդ արգումենտն ունի լռելյալն արժեք, որը երկուս է։ Այսինքն՝ եթե երկրորդ արգումենտին արժեք չփոխանցենք, ապա կվերադարձվի առաջին արգումենտի քառակուսին։ Ֆունկցիան կանչելիս և դրան արգումենտներ փոխանցելիս կարելի է արգումենտի անունը, որին փոխանցվում է արժեքը, չնշել։ Այդ դեպքում տեղի կունենա արգումենտների հավասարեցում փոխանցված արժեքներին՝ դիրքի միջոցով։ Օրինակ՝\n\nPower(10)\n\n[1] 100\n\n\nԱյս դեպքում փոխանցված արժեքը տրվում է առաջին արգումենտին, իսկ երկրորդ արգումենտը կարող է և արժեք չստանալ, քանի որ այն լռելյալն արժեք ունի։ Արգումենտների անունները նշելուց հետո հնարավոր է արգումենտների դիրքերը նշել իրենց սահմանված դիրքերին չհամապատասխանող՝\n\nPower(base = 5, exp = 3)\n\n[1] 125\n\nPower(exp = 3, base = 5)\n\n[1] 125\n\n\nՀնարավոր է նաև անունների մասնակի նշում կամ միայն մի արգումենտի նշում անունով, իսկ մյուսների նշում դիրքով՝\n\nPower(base = 16, e = 1.5)\n\n[1] 64\n\n#or, using the names and the positions\nPower(base = 16, 1.5)\n\n[1] 64\n\n\nԱրգումենտի նշման երեք ձևերը՝ անունով, դիրքով և մասնակի անունով միասին կիրառելիս տեղի ունի կատարման հետևյալ հերթականությունը՝ 1. անունով, 2. մասնակի անունով և ամենավերջում այն արգումենտները որոնք դեռևս կանչված չեն կարող են դիմվել դիրքով։\nԱյժմ ստեղծենք ֆունկցիա, որը հաշվում է տրված մատրիցի տողերի կամ սյուների միջին արժեքներից բաղկացած վեկտոր։\n\nAverage &lt;- function(x, bycol = TRUE){\n  if(!bycol) x &lt;- t(x)\n  nc &lt;- ncol(x)\n  av_values &lt;- vector(mode = \"numeric\", length = nc)\n  for(i in seq_len(nc)){\n    av_values[i] &lt;- mean(x[,i])\n  }\n  av_values\n  \n}\n\nM1 &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12), ncol = 3)\nAverage(M1)\n\n[1]  2.5  6.5 10.5\n\nAverage(M1, bycol = FALSE)\n\n[1] 5 6 7 8\n\nAverage(t(M1), bycol = FALSE)\n\n[1]  2.5  6.5 10.5\n\n\nՖունկցիայի արգումենտների անունները ստանալու համար կարելի է օգտագործել նախասահմանված args() ֆունկցիան՝\n\nargs(Average)\n\nfunction (x, bycol = TRUE) \nNULL\n\n\nՍտացվեց, որ ֆունկցիային որպես արգումենտ հնարավոր է ֆունկցիա փոխանցել։ Ավելի խորությամբ ուսումնասիրենք այս հատկությունը։ Սահմանենք ֆունկցիա, որը ստանում է երեք արգումենտ՝ վեկտոր, որը պարունակում է տվյալները, երկարությունը, որով պետք է կտրել նախորդ վեկտորը և ֆունկցիա, որը պետք է կիրառել կտրված վեկտորի վրա։\n\nStatistic &lt;- function(func, x, n){\n  func(x[1:n])\n}\n\nx &lt;- 1:100\nStatistic(mean, x = x, n = 10)\n\n[1] 5.5\n\nStatistic(sd, x, 25)\n\n[1] 7.359801\n\nStatistic(func = max, x = x, n = 98)\n\n[1] 98\n\n\n-ում հնարավոր է ֆունկցիան փոխանցել որպես արգումենտ անգամ եթե այն դեռևս սահմանված չէ և սահմանվում է հենց օգտագործելիս։ Նախապես չսահմանված ֆունկցիան կոչվում է անանուն ֆունկցիա (anonymous function): Դիտարկենք հետևյալ օրինակը՝\n\nStatistic(function(x){ x^2 }, x = x, n = 5)\n\n[1]  1  4  9 16 25\n\n\nՄեր սահմանած Statistic() ֆունկցիան կիրառում է տրված ֆունկցիան տրված վեկտորի վրա՝ վերջինս կտրելուց հետո։ Վերը նշված օրինակում մենք որպես արգումենտ փոխանցում ենք քառակուսի բարձրացնող ֆունկցիան, որը, սակայն, դեռևս սահմանված չէր և սահմավում է Statistic() ֆունկցիայի արգումենտում և միայն այդտեղ գոյություն ունի։\n\n\n2.5.2 Հրամանի կատարում ըստ անհրաժեշտության (Lazy Evaluation)\nՖունկցիայի արգումենտների վերագրումը կատարվում է ըստ անհրաժեշտության։ Դիտարկենք հետևյալ օրինակը՝\n\nf &lt;- function(a, b){\n  a + 2\n}\nf(10)\n\n[1] 12\n\n\nԹեև վերը նշված ֆունկցիայում մենք արժեք չենք վերագրում b արգումենտին ու այն չունի լռելյալն արժեք, բայց, այնուամենայնիվ, սխալ տեղի չի ունենում և ֆունկցիան արժեք է վերադարձնում։ Պատճառն այն է, որ ֆունկցիան գործողություն կատարելու համար չունի b-ի կարիքը, այդ պատճառով էլ այն չի կանչում b-ի արժեքը։ Սա կոչվում է հրամանի կատարում ըստ անհրաժեշտության։\n\n\n2.5.3 Բազմակետ արգումենտը (Ellipsis or dot-dot-dot)\nԴիտարկենք նախասահմանված paste() ֆունկցիան, որը տրված վեկտորները միավորում է մեկ տեքստային փոփոխականի մեջ։ Օրինակ՝\n\npaste(\"Hello\", \"World\", \"of\", \"R\")\n\n[1] \"Hello World of R\"\n\n\nԴիտարկենք այս ֆունկցիայի արգումենտները՝\n\nargs(paste)\n\nfunction (..., sep = \" \", collapse = NULL, recycle0 = FALSE) \nNULL\n\n\nԻնչպես տեսնում ենք՝ առաջին արգումենտի տեղում գրված է բազմակետը՝ \\(\\cdots\\)։ Դա նշանակում է, որ կարող ենք փոխանցել ցանկացած քանակով վեկտորներ և դրանք կմիավորվեն մեկ տեքստային փոփոխականի մեջ։ Բազմակետով նշված արգումենտը սովորաբար ամենավերջին արգումենտն է լինում, ինչը տեղի չունի վերը նշված paste() ֆունկցիայի դեպքում։ Եթե բազմակետ արգումենտից հետո այլ արգումենտներ են սահմանված, ապա դրանք անպայմանորեն պետք է ունենան լռելյալն արժեքներ և դրանց դիմելիս անունները պետք է նշվեն ամբողջությամբ։ Հետևաբար բոլոր այն ֆունկցիաներում որտեղ առաջին արգումենտը բազմակետն է բոլոր արգումենտների անունները պետք է նշվեն ամբողջությամբ՝\n\npaste(\"a\", \"b\", sep = \":\")\n\n[1] \"a:b\"\n\npaste(\"a\", \"b\", se = \":\")\n\n[1] \"a b :\"\n\n\nԵրկրորդ հրամանը չտվեց նույն արդյունքը ինչ առաջինը քանի որ մենք արգումենտի անունը մասնակի ենք նշել այդ պատճառով դրա անունն անտեսվել է, իսկ դրա արժեքը հասկացվել է որպես հերթական վեկտոր, որը պետք է միացնել նախորդներին։\nԱյժմ տեսնենք թե ինչպես կարող ենք դիմել բազմակետում նշված արգումենտներին (unpack dot-dot-dot arguments), երբ պետք է լինում նման արգումենտով ֆունկցիա սահմանել։\nՍտորև գրված ֆունկցիան ստանում է անորոշ քանակով արգումենտներ և ստացված արգումենտների միջից գտնում է նրանք, որոնք ունեն \\(salary\\) և \\(per\\) անունները։ Եթե այդպիսիք կան, ապա ֆունկցիան հաշվում է աշխատավարձի աճը՝ տրված տոկոսով, իսկ եթե այդ թվերից որևէ մեկը բացակայում է՝ վերադարձնում է համապատասխան հաղորդագրություն։ Բազմակետով տրված արգումենտի բոլոր արժեքները հնարավոր է պահել ցուցակի ներսում։\n\nSalary_Increase &lt;- function(...){\n  Args &lt;- list(...)\n  if(is.null(Args[[\"salary\"]]) | is.null(Args[[\"per\"]])) x &lt;- \"Information is Missing\"\n  else x &lt;- Args[[\"salary\"]] + Args[[\"salary\"]]*Args[[\"per\"]]/100\n  x\n}\n\nSalary_Increase(first = \"John\", last = \"Tyson\", salary = 125000, per = 25)\n\n[1] 156250\n\nSalary_Increase(first = \"Mike\", last = \"Mason\", salary = 130000, country = \"USA\")\n\n[1] \"Information is Missing\"\n\nSalary_Increase(first = \"Bill\", last = \"Johnson\", city = \"Seattle\", company = \"Amazon\")\n\n[1] \"Information is Missing\"\n\n\nԲազմակետ արգումենտը մեկ այլ կարևոր կիրառություն ևս ունի. այն օգտագործվում է նշելու համար ֆունկցիայի արգումենտները որոնք փոխանցվում են այլ ֆունկցիաների։ Սա հաճախ օգտագործվում է գոյություն ունեցող ֆունցիաներն ընդլայնելիս՝ հին ֆունկցիայի բոլոր արգումենտները չպատճենելու համար։\nՈրպես օրինակ դիտարկենք վերը սահմանված \\(Statistic()\\) ֆունկցիան՝ կիրառած անհայտ արժեքներ պարունակող վեկտորի վրա՝\n\nStatistic &lt;- function(func, x, n = length(x)){\n  func(x[1:n])\n}\n\nStatistic(mean, c(NA, 1, 2, NA, 3))\n\n[1] NA\n\n\nԱրժեքը NA է, քանի որ վեկտորը պարունակում է NA արժեքներ։ Նախասահմանված mean() ֆունկցիան ունի արգումենտ, որի արժեքը TRUE դնելու դեպքում միջինը հաշվելիս վեկտորից հեռացվում են բոլոր NA արժեքները։\n\nmean(c(NA, 1, 2, NA, 3), na.rm = TRUE)\n\n[1] 2\n\n\nԱյժմ փորձենք այնպես սահմանել Statistic() ֆունկցիան, որ mean() ֆունկցիան նրան փոխանցելիս հնարավոր լինի այս արգումենտը ևս օգտագործել։ Սա կարող ենք կատարել վերը նշված բազմակետ արգումենտի միջոցով՝\n\nStatistic &lt;- function(func,x, n = length(x), ...){\n  func(x[1:n], ...)\n}\n\nStatistic(fun = mean, x = c(NA, 1, 2, NA, 3), na.rm = TRUE)\n\n[1] 2\n\n\nՆշելով բազմակետը ֆունկցիայի սահմանման մեջ մենք տեղեկացնում ենք, որ func արգումենտին փոխանցված ֆունկցիան կարող է ստանալ նաև արգումենտներ։\n\n\n2.5.4 Բինար գործողություններ (Binar Operators)\nՖունկցիաները որոնք ունեն երկու արգումենտներ կոչվում են բինար գործողություններ։ Բինար գործողությունների ամենահայտնի օրինակներն են թվաբանական գործողությունները։\n\n4 + 5\n\n[1] 9\n\n`+`(4, 5)\n\n[1] 9\n\n\nՍահմանենք նոր բինար գործողություններ։ Ստորև սահմանված բինար գործողությունը միացնում է տրված երկու տեքստային արժեքները մեկ փոփոխականի մեջ։ Բինար գործողությունը պետք է ունենա անունի հատուկ գրելաձև՝ \\%name\\%:\n\n\"%c%\" &lt;- function(x, y) paste(x, y)\n\n\"Hello\" %c% \"World\"\n\n[1] \"Hello World\"\n\n\"Hello\" %c% \"World\" %c% \"of\" %c% \"R\" \n\n[1] \"Hello World of R\"\n\n\n\n\n2.5.5 Սխալների վերհանումը ֆունկցիայում (Debugging)\nԵրբ ծրագրային իրագործումն աշխատեցնելիս խնդիրներ են ծագում, -ը ծրագրավորողի հետ հաղորդակցվելու համար օգտագործում է հաղորդագրությունների որոշ տեսակներ։ \\(message\\)-ը ամենապարզ հաղորդագրությունն է, որի առկայությունը չի նշանակում, թե խնդիր է ծագել։ Պազապես նշվում է որոշակի տեղեկատվություն կատարված հրամաների մասին։ Պարզ հաղորդագրությունները հաճախ հանդիպում են նոր գրադարաններ ակտիվացնելիս, երբ կարճ ներկայացվում է թե ինչ է անհրաժեշտ այդ գրադարանների աշխատանքի համար, կամ պարզապես տեղեկացվում է գրադարանների ստեղծողների մասին։\n\nmessage(\"Hello\")\n\nHello\n\n\nՀաղորդագրության հաջորդ տեսակը զգուշացումն է՝ \\(warning\\), որը ցույց է տալիս, որ անսպասելի արդյունք է ստացվել, որը, սակայն, չի կասեցրել ծրագրի իրագործումը և իրագործման արդյունքը ստացվում է։ Զգուշացումը ստացվում է ծրագրային իրագործման արդյունքը ստացվելուց հետո և ոչ այն պահին, երբ անսպասելի արդյունքը գրացվել է։ Որպես օրինակ դիտարկենք հետևյալ կանչը\n\nwarning(\"Hello\")\n\nWarning: Hello\n\n\nՀաղորդակցության մյուս տեսակը սխալի տեղի ունենալու մասին հաղորդագրությունն է՝ \\(error\\): Դրա հայտնվելը «ճակատագրական» ազդեցություն է ունենում և ծրագրի իրագործումը դադարում է, տպվում է համապատասխան հաղորդագրությունը։ Սխալի արտատպման ֆունկցիան է \\(stop()\\):\n\nstop(\"Hello\")\n\nՎերը նշված բոլոր հաղորդագրությունները նույն գաղափարի՝ պայմանական իրագործման (conditional execution) տարատեսակներ են։ Ծրագրավորողը կարող է նախատեսել, որ իր ստեղծած ֆունկցիան բազմազան հաղորդագրություններ ուղարկի օգտագործողին՝ որոշակի պայմանների տեղի ունենալու դեպքում։\n\nSqrt &lt;- function(x){\n  if(x &lt; 0){\n    warning(paste(x, \"is a negative number, it is converted to a complex number\"))\n    x &lt;- as.complex(x)\n  } \n    sqrt(x)\n}\nSqrt(-1)\n\nWarning in Sqrt(-1): -1 is a negative number, it is converted to a complex\nnumber\n\n\n[1] 0+1i\n\n\n\nSqrt_ &lt;- function(x){\n  if(x &lt; 0){\n    print(paste(x, \"is a negative number. Please, enter a positive number.\"))\n    } \n    else return(sqrt(x))\n}\nSqrt_(-1)\n\n[1] \"-1 is a negative number. Please, enter a positive number.\"\n\nSqrt_(256)\n\n[1] 16\n\n\nԵրբ ֆունկցիան աշխատեցնելիս սխալ է տեղի ունենում շատ դժվար է բացահայտել, թե որ քայլում է տեղի ունեցել սխալը։ Այդ պատճառով անհրաժեշտ է ֆունկցիայի ներսում քայլ առ քայլ կատարել հրամանները և տեսնել, թե որ քայլում է սխալը տեղի ունենում։ Սխալների վերհանման (debugging) համար կարելի է օգտագործել հետևյալ հնարքը։ Ենթադրենք սահմանել են ստորև բերված ֆունկցիան,\n\nAverage &lt;- function(x, bycol = TRUE){\n  if(!bycol) x &lt;- t(x)\n  nc &lt;- ncol(x)\n  av_values &lt;- vector(mode = \"numeric\", length = nc)\n  for(i in seq_len(nc)){\n    av_values[i] &lt;- mean(x[, i])\n  }\n  av_values\n}\n\nև այն սխալ է տվել արգումենտների որևէ արժեքների համար կանչելիս՝\n\nM1 &lt;- matrix(1:12, ncol = 3)\nAverage(M1, bycol = FALSE)\n\nՈրպեսզի պարզենք, թե որ քայլում է սխալը տեղի ունեցել, կարող ենք արգումենտների անուններին համապատասխան գլոբալ փոփոխականներ ստեղծել՝ մինչ ֆունկցիայի սահմանումը, դրանց վերագրել այն արժեքները, որոնց դեպքում ֆունկցիայում սխալ էր տեղի ունենում, և աշխատեցնել ֆունկցիայի ներսում գրված հրամանները՝ առանց ֆունկցիայի սահմանման՝\n\nM1 &lt;- matrix(1:12, ncol = 3)\nx &lt;- M1; bycol &lt;- FALSE\n#Average &lt;- function(x, bycol = TRUE){ \n  if(!bycol) x &lt;- t(x)\n  nc &lt;- ncol(x)\n  av_values &lt;- vector(mode = \"numeric\", length = nc)\n  for(i in seq_len(nc)){\n    av_values[i] &lt;- mean(x[, i])\n  }\n  av_values#}\n\n[1] 5 6 7 8\n\n\nԱյս դեպքում հրամանները չեն իրագործվի որպես մեկ ամբողջություն և հնարավորություն կլինի տեսնել այն հրամանը, որն աշխատեցնելիս սխալ է տեղի ունենում։\n\n\n2.5.6 Արժեքների կցում (Symbol Binding)\nԱյս բաժնում քննարկելու ենք փոփոխականին արժեքներ կցելու սկզբունքները։ Դիտարկենք նախասահմանված \\(\\pi\\) թիվը՝\n\npi\n\n[1] 3.141593\n\n\nԱյժմ \\(pi\\) փոփոխականին վերագրենք այլ արժեք և տպենք այն՝\n\npi &lt;- 4\npi\n\n[1] 4\n\n\nՀարց է առաջանում, թե ինչու -ը տպեց մեր վերագրած թիվը այլ ոչ թե նախասահմանվածը։ Երբ մենք կանչում ենք փոփոխականը, ապա -ը սկսում է դրա արժեքը փնտրել տարբեր միջավայրներում՝ environments, որոնք կարելի է հասկանալ որպես օբյեկտների և դրանց արժեքների ցուցակ։ Չգտնելով տրված միջավայրում, այն անցնում է հաջորդ միջավայրերում փնտրելու՝ մինչ գտնելը։ Երբ տրված անունով փոփոխականի արժեքը գտնվում է, որոնումը դադարում է, իսկ երբ որևէ միջավայրում այն չի գտնվում՝ վերադարձվում է սխալի տեղի ունենալու հաղորդագրությունը։ Միջավայրերի հերթականությունը որոնցում կատարվում է որոնումը կարելի է տեսնել search() նախասահմանված ֆունկցիայի միջոցով՝\n\nsearch()\n\n[1] \".GlobalEnv\"        \"package:stats\"     \"package:graphics\" \n[4] \"package:grDevices\" \"package:utils\"     \"package:datasets\" \n[7] \"package:methods\"   \"Autoloads\"         \"package:base\"     \n\n\nԻնչպես տեսնում ենք՝ որոնումը սկզբում կատարվում է գլոբալ միջավայրում (global environment), որտեղ պահվում են ծրագրավորողի կողմից սահմանված արժեքները, իսկ այդտեղ չգտնելու դեպքում, հերթականությամբ դիտարկվում են բոլոր նախասահմանված գրադարաններում։ Երբ նոր գրադարան է կցվում, ապա այն հայտնվում է արդեն կցված գրադարաններից առաջ և ստանում առաջնահերթություն՝ որոնում կատարելիս։\n\nlibrary(HistData)\nsearch()\n\n [1] \".GlobalEnv\"        \"package:HistData\"  \"package:stats\"    \n [4] \"package:graphics\"  \"package:grDevices\" \"package:utils\"    \n [7] \"package:datasets\"  \"package:methods\"   \"Autoloads\"        \n[10] \"package:base\"     \n\n\nԿարևոր է հիշել, որ -ը ֆունկցիաների և ոչ-ֆունկցիաների անունները տարբեր տեղերում է պահում, հետևաբար հնարավոր է միաժամանակ ունենալ, օրինակ, \\(c\\) անունով և՛ փոփոխական և՛ ֆունկցիա։\nՓոփոխականին արժեքի կցումը ֆունկցիայի ներսում ունի իր առանձնահատկություները, որին կանդրադառնանք հաջորդ բաժնում։\n\n\n2.5.7 Ներդրված ֆունկցիաներ\n-ում հնարավոր է սահմանել ներդրված ֆունկցիաներ։ Ֆունկցիայի մեջ մեկ այլ ֆունկցիայի սահմանումը ոչ բոլոր ծրագրավորման լեզուներում է հնարավոր։ Այն առավելապես հարմար է վիճակագրական ֆունկցիաների հետ աշխատելիս, երբ անհրաժեշտ է ֆունկցիա սահմանել, որն ուրիշ ֆունկցիաներ է կառուցում։ Երբեմն անհնաժեշտություն է առաջանում տրված երկու փոփոխականների ֆունկցիայի համար գտնել դրա նվազագույն արժեքը ըստ փոփոխականներից որևէ մեկի՝ մյուս փոփոխականի որևէ ֆիքսված արժեքի դեպքում։ Օրինակ, ֆունկցիաների տրված ընտանիքի դեպքում\n\\[\\left\\{f(x,\\theta)=\\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{(x-\\theta)^2}{2}},\\,\\theta,x\\in {\\bf{\\rm R}}\\right\\}\\]\nեթե ուզում ենք տրված \\(x=x_0\\) արժեքի դեպքում ստանալ \\(f_0(\\theta)=f(x_0,\\theta)\\) կարող ենք սահմանել հետևյալ կերպ՝\n\nFunc &lt;- function(x){\n  function(x = x, theta) (1/sqrt(2 * pi))*exp(- (x - theta)^2 / 2)\n}\n\nFunc0 &lt;- Func(0)\nclass(Func0)\n\n[1] \"function\"\n\nargs(Func0)\n\nfunction (x = x, theta) \nNULL\n\n\n\n\n2.5.8 Տեսանելիության շրջանակ (Scoping Rules)\nՏեսանելիության շրջանակը որոշում է այն կանոները որոցով ֆունկցիայի ներսում կատարվում է ազատ փոփոխականին արժեքի կցումը։ -ում տեղի ունի ստատիկ կցումը (lexical scoping or static scoping): Սրա ամենատարածված այլընտրանքը դինամիկ կցումն է (dynamic scoping):\nՖունկցիայի ներսում կան երկու տեսակի փոփոխականներ՝ որպես արգումենտ սահմանվածները կամ հենց ֆունկցիայի ներսում սահմանվածներ և ազատ փոփոխականները որոնք արգումենտներ չեն և սահմանված չեն ֆունկցիայի ներսում, այլ սահմանված են ֆունկցիայից դուրս։\nՍտատիկ կցման ժամանակ ազատ փոփոխականների արժեքները փնտրվում են այն միջավայրում, որտեղ ֆունկցիան սահմանված է։ Միջավայրը (environment) փոփոխականի անուն, արժեք զույգերի բազմություն է։ Յուրաքանչյուր միջավայր ունի իրեն ծնող միջավայրը (parent environment) և հնարավոր է, որ մի միջավայրը ծնի մեկից ավելի միջավայրներ։ Միակ միջավայրն առանց իրեն ծնող միջավայրի դատարկ միջավայրն է (empty environment), իսկ ֆունկցիան իրեն ծնող միջավայրի հետ միասին կոչվում է ֆունկցիայի լրացում կամ փակում (closure or function closure): Տրված անունով ազատ փոփոխականի արժեքը գտնելու համար փնտրումը նախ կատարվում է այն միջավայրում, որտեղ ֆունկցիան սահմանված է։ Այդտեղ չգտնելու դեպքում որոնումը շարունակվում է նշված միջավայրը ծնող միջավայրում և այդպես շարունակ մինչև գլոբալ միջավայրը։ Եթե այս ընթացքում արժեքը չի գտնվում, որոնումը փոխում է ուղղությունը և սկսում ներքև իջնել միջավայրների մեջ փնտրելով մինչ կհասնի դատարկ միջավայրին։ Եթե այս ընթացքում ևս փոփոխականի արժեքը չի գտնվում տեղի է ունենում սխալ։\n\n\n2.5.9 Օրինակներ\n\nԴիտարկենք հետևյալ ֆունկցիաները՝\n\n\nfun1 &lt;- function(x) x + y\n\nfun2 &lt;- function() {\n  y &lt;- 20\n  function(x) x + y\n}\n\nԱռաջինը սովորական ֆունկցիա է որում y-ն ազատ փոփոխական է, իսկ երկրորդը ֆունկցիա է, որը ստեղծում է այլ ֆունկցիա։ Երկրորդի միջոցով ստեղծենք fun3() ֆունկցիան՝\n\nfun3 &lt;- fun2()\n\nԴիտարկենք fun1() և fun3() ֆունկցիաների կառուցվածքները՝\n\nfun1\n\nfunction (x) \nx + y\n\nfun3\n\nfunction (x) \nx + y\n&lt;environment: 0x0000021f38b5d008&gt;\n\n\nԻնչպես տեսնում ենք՝ երկու ֆունկցիաներն էլ ունեն նույն կառուցվածքը և կատարում են նույն գործողությունը, միակ տարբերությամբ, որ երկրորդ ֆունկցիայի սահմանման հետ տրված է նաև այն միջավայրը որում այն սահմանված է։ Սա արվում է այն դեպքում, երբ ֆունկցիան սահմանված չէ գլոբալ միջավայրում, այլ որևէ ֆունկցիայի ներսում։\n\ny &lt;- 10\nfun1(5)\n\n[1] 15\n\nfun3(5)\n\n[1] 25\n\n\nԻնչպես տեսնում ենք՝ երկու ֆունկցիաներն ունեն նույն կառուցվածքը, բայց տարբեր արժեքներ վերադարձրեցին արգումենտի նույն արժեքի դեպքում։ Պատճառը ֆունկցիայի ներսում առկա անկախ փոփոխականին արժեք վերագրելու սկզբունքի մեջ է։ Երկրորդ ֆունկցիան սահմանված է մեկ այլ ֆունկցիայի ներսում, հետևաբար ազատ փոփոխականի արժեքը փնտրվում է, հենց այդ՝ սկզբնական ֆունկցիայի մեջ, այլ ոչ թե գլոբալ միջավայրում։\n\nenvironment(fun1)\n\n&lt;environment: R_GlobalEnv&gt;\n\nenvironment(fun3)\n\n&lt;environment: 0x0000021f38b5d008&gt;\n\nget(\"y\", environment(fun1))\n\n[1] 10\n\nget(\"y\", environment(fun3))\n\n[1] 20\n\n\n\nՏեսնենք թե ինչ առավելություն է տալիս ստատիկ տեսանելիության հատկությունը -ում։ Դիտարկենք \\(N(\\theta,\\sigma^2)\\) նորմալ բաշխման ճշմարտանմանության ֆունկցիան՝ տրված (հայտնի) \\(\\sigma&gt;0\\) արժեքի դեպքում: Այդ բաշխման խտության ֆունկցիան է՝\n\n\\[\\left\\{f(x,\\theta,\\sigma^2)=\\frac{1}{\\sqrt{2\\pi\\sigma^2}}e^{-\\frac{(x-\\theta)^2}{2\\sigma^2}},\\,\\theta,\\,x\\in {\\bf{\\rm R}}\\right\\},\\ \\ \\sigma&gt;0.\\] Իսկ ճշմարտանմանության ֆունկցիան տրված \\(X^n=(X_1,\\cdots,X_n)\\) նմուշի համար կլինի՝\n\\[L(X^n,\\theta)=\\frac{1}{(2\\pi\\sigma^2)^\\frac{n}{2}}e^{-\\frac{1}{2\\sigma^2}\\sum_{i=1}^n(X_i-\\theta)^2}=\\frac{1}{(2\\pi\\sigma^2)^\\frac{n}{2}}e^{-\\frac{n}{2\\sigma^2}\\left(\\frac{1}{n}\\sum_{i=1}^nX_i^2-\\frac{2\\theta}{n}\\sum_{i=1}^nX_i+\\theta^2\\right)},\\,\\theta,\\,x\\in {\\bf{\\rm R}},\\ \\ \\sigma&gt;0.\\] Տրված \\(X^n\\) ընտրանքի և \\(\\sigma\\) դրական թվի համար պետք է գտնել այս ֆունկցիայի առավելագույն արժեքը, հետևաբար նախ գրենք ֆունցկիա, որ կկառուցի այս ճշմարտանմանության ֆուկցիան։\n\nLike &lt;- function(X,sigma){\n  n &lt;- length(X)\n  Mean_X &lt;- mean(X)\n  Mean_X2 &lt;- mean(X^2)\n  \n  function(x = Mean_X, y = Mean_X2, size = n, sd = sigma, theta){\n    (2*pi*sd^2)^( - size/2)*exp( - 1/(2*sd^2*size)*(y - 2*theta*x + theta^2))\n  }\n}\nset.seed(1)\nX &lt;- rnorm(100,1,2)\nOpt &lt;- Like(X, sigma = 2)\nclass(Opt)\n\n[1] \"function\"\n\n\n\n\n\n\n\n\n\n\n\nՎիճակագրությունից գիտենք, որ ճշմարտանմանության ֆունկցիան իր առավելագույն արժեքին հասնում է \\(\\hat\\theta_n=\\frac{1}{n}\\sum_{i=1}^n X_i\\) կետում՝\n\nmean(X)\n\n[1] 1.217775\n\n\nԻնչպես տեսնում ենք Like() ֆունկցիայի ներսում սահմանված ֆունկցիան ունի ընդամենը մեկ ազատ փոփոխական՝ pi, որին արժեք է կցվում գլոբալ միջավայրից (այն իրականում առկա չէ գլոբալ միջավայրում և որոնումը շարունակվում է նախասահմանված գրադարաններում՝ մինչ base գրադարանից արժեքի կցումը)։  հաշվողական միջավայրը, ինչպես նշել են, առաջացել է S հաշվողական լեզվից և հիմնական տարբերությունն այս լեզուների մեջ հենց տեսանելիության շրջանակն է։ S լեզվում ազատ փոփոխականների վերագրումը կատարվում է միայն գլոբալ միջավայրում, անգամ եթե տրված ֆունկցիան ներդրված է մեկ այլ ֆունկցիայում։ Հետևաբար վերը գրված ծրագիրը կաշխատի ինչպես S-ում այնպես և -ում։ Բայց ի տարբերություն S-ի -ում ազատ փոփոխականների վերագրումը կատարվում է ֆունկցիայի սահմանման միջավայրում, հետևաբար վերը նշված ծրագիրը կարելի է պարզեցնել՝\n\nLike0 &lt;- function(X, sigma){\n  n &lt;- length(X)\n  Mean_X &lt;- mean(X)\n  Mean_X2 &lt;- mean(X^2)\n  \n  function(theta){\n    (2*pi*sigma^2)^(-n/2)*exp(-1/(2*sigma^2*n)*(Mean_X2 - 2*theta*Mean_X + theta^2))\n  }\n}\nset.seed(1)\nX &lt;- rnorm(100,1,2)\nOpt0 &lt;- Like0(X, sigma = 2)\nclass(Opt0)\n\n[1] \"function\"\n\nargs(Opt0)\n\nfunction (theta) \nNULL\n\n\n\n\n\n\n\n\n\n\n\nՍտացվեց, որ ֆունկցիայի ներսում սահմանված ֆունկցիան իր ազատ փոփոխականներին արժեքներ կցելիս կարող է օգտագործել ինչպես սկզբնական ֆունկցիայի արգումենտները, այնպես էլ սկզբնական ֆունկցիայի ներսում սահմանված լոկալ փոփոխականները։ Նախորդ դեպքում այս երկու տեսակի արժեքները պետք է փոխանցվեին որպես երկրորդ ֆունկցիայի փոփոխականներ, որպեսզի երկրորդ ֆունկցիան կարողանար դրանք օգտագործել։\n\nint &lt;- seq(- 3, 3, 0.001)\nX &lt;- rnorm(100, 1, 2)\nf1 &lt;- Like0(X, sigma = 2)\noptimize(f1, int, maximum = TRUE) #optimize by default minimizes\n\n$maximum\n[1] 0.9244036\n\n$objective\n[1] 5.502102e-76\n\nmean(X)\n\n[1] 0.9243838\n\n\n\nX &lt;- rnorm(100, 1, 2)\nf2 &lt;- Like0(X, sigma = 2)\noptimize(f2, int, maximum = TRUE)\n\n$maximum\n[1] 1.059357\n\n$objective\n[1] 5.497959e-76\n\nmean(X)\n\n[1] 1.059347\n\n\nԻնչպես տեսնում ենք՝ տարբեր \\(X\\) նմուշների միջոցով կառուցվում են տարբեր՝ \\(f_1,\\,f_2\\) ֆունկցիաներ և յուրաքանչյուրն օգտագործում է այն նմուշը, որի միջոցով այն կառուցվել է։ Սա տեղի է ունենում քանի որ յուրաքանչյուր ֆունկցիա իր մեջ պահում է նաև այն միջավայրը, որում այն կառուցվել է։ Սա կոչվում է ֆունկցիայի փակում՝ function closure:\n\nՀաջորդ օրինակը ցույց է տալիս, թե ինչով է ստատիկ կցումը տարբերվում դինամիկ կցումից։\n\n\ny&lt;-10\n\nf&lt;-function(x){\n  y&lt;-2\n  y^2+g(x)\n}\n\ng &lt;- function (x) {\n  x*y\n}\n\nԿախված նրանից թե կցման ինչ տարբերակ է օգտագործում հաշվողական լեզուն, \\(f(3)\\) ֆունկցիայի կանչը կտա տարբեր արժեքներ։\n\nf(3)\n\n[1] 34\n\n\nՍտատիկ կցման ժամանակ (հետևաբար նաև -ում), \\(g()\\) ֆունկցիայի ներսում առկա \\(y\\) ազատ փոփոխականի արժեքը կցվում է \\(g()\\) ֆունկցիայի սահմանման ժամանակ և, հետևաբար, դրա արժեքը փնտրվում է միջավայրում, որտեղ \\(g()\\) ֆունկցիան սահմանվել է, այսինքն՝ այս դեպքում գլոբալ միջավայրում, հետևաբար \\(y=10\\): Դինամիկ կցման ժամանակ \\(y\\) արժեքի վերագրումը կկատարվեր այն ժամանակ, երբ \\(g()\\) ֆունկցիան կանչվեր, այսինքն՝ \\(f()\\) ֆունկցիայի ներսում, հետևաբար \\(y\\)-ի արժեքը կփնտրվեր \\(g()\\)-ի կանչման միջավայրում, որը կոչվում է նաև \\(g()\\)-ի ծնող կառուցվածք (parent frame)։\n\nԵրբ ֆունկցիան սահմանված է գլոբալ միջավայրում և կանչվում է գլոբալ միջավայրից, ապա ֆունկցիայի կանչման և սահմանման միջավայրերը նույնն են և կարող է թվալ, որ տեղի է ունենում դինամիկ կցում՝\n\n\ng &lt;- function(x){\n  a &lt;- 3\n  x+a+y\n}\n\n# g(2) will give an error because \"y\" is not defined\n\ny &lt;- 3\ng(2)\n\n[1] 8\n\n\nԹվում է՝ \\(g()\\) ֆունկցիայի ներսում առկա \\(y\\) ազատ փոփոխականին արժեքի կցումը կատարվեց ոչ թե \\(g()\\) ֆունկցիայի սահմանման ժամանակ, քանի որ այդ ժամանակ դեռևս \\(y\\)-ը սահմանված չէր, այլ \\(g()\\)-ի կանչման ժամանակ։ Իրականում այստեղ ևս տեղի է ունենում ստատիկ կցում, պարզապես ֆունկցիայի սահմանման և կանչման միջավայրների նույնը լինելու պատճառով նման տպավորություն է ստեղծվում։\nՍտատիկ կցման հետևանքներից է, որ -ում սահմանված բոլոր օբյեկտները պետք է պահվեն հիշողության մեջ, ինչպես նաև բոլոր ֆունկցիաները պետք է պահեն ցուցիչ միջավայրի վրա որտեղ իրենք սահմանվել են։\n\n\n2.5.10 Վերագրման գործողություններ\n-ում կան երեք վերագրման գործողություններ՝ &lt;-, =, &lt;&lt;-: Դրանց միջև տարբերությունը այդ վերագրումների տեսանելիության շրջանակն է, որտեղ են դրանց միջոցով վերագրում կատարված փոփոխականները հասանելի։ Դիտարկենք հետևյալ օրինակները՝\n\nՔանի՞ փոփոխական կստեղծի հետևյալ հրամանը՝\n\n\nrm(list=ls())\n\nx &lt;- c(a = 1, b = 3)\n\nՊատասխան\nԸնդամենը մեկ փոփոխական՝ x-ը։ Մյուս վերագրման գործողությունն օգտագործվում է c() ֆունկցիայի արգումենտում արժեքներին անուններ տալու համար։ Այսինքն՝ a և b փոփոխականները գոյություն ունեն միայն x փոփոխականի ներսում։\n\nls()\n\n[1] \"x\"\n\nx\n\na b \n1 3 \n\n\n\nՔանի՞ փոփոխական կստեղծի հետևյալ հրամանը՝\n\n\nrm(list = ls())\nx &lt;- c(a &lt;- 1, b &lt;- 3)\n\nՊատասխան\nԱյն կստեղծի երեք փոփոխականներ՝ գլոբալ միջավայրում։ Թեև a և b փոփոխականներին արժեք է վերագրվում c() ֆունկցիայի արգումենտում, բայց նշված վերագրման տեսակի պատճառով վերագրումը կատարվում է գլոբալ միջավայրում։\n\nls()\n\n[1] \"a\" \"b\" \"x\"\n\nx\n\n[1] 1 3\n\n\n\nԻ՞նչ կվերադարձնի հետևյալ հրամանը՝\n\n\nrm(list = ls())\nmean(z = 1:4)\n\nՊատասխան\nԱյստեղ տեղի է ունենալու սխալ, որովհետև mean() ֆունկցիան չունի z անունով արգումենտ, նաև ֆունկցիայի արգումենտում վեկտորի z=1:4 սահմանումը տեսանելի չէ գլոբալ միջավայրում, իսկ mean() ֆունկցիան արժեքները փնտրում է գլոբալ միջավայրում։\n\n\n&lt;getvarError in mean.default(z = 1:4): argument \"x\" is missing, with no default&gt;\n\n\n\nՆախորդ օրինակը ձևափոխելով հետևյալ կերպ, հաշվարկը տեղի կունենա\n\n\nrm(list = ls())\nmean(z &lt;- 1:4)\n\n[1] 2.5\n\n\n\nՎերագրման երրորդ օրինակը՝ &lt;&lt;- թույլ է տալիս ֆունկցիայի ներսում կատարել վերագրում, որը տեսանելի կլինի այն միջավայրում, որտեղ ֆունկցիան ստեղծվել է։\n\n\nrm(list = ls())\nx &lt;- 10\nchange &lt;- function() x &lt;&lt;- 12\nchange()\nx\n\n[1] 12\n\n\nՎերագրման այս տեսակը կարող է օգտագործվել, օրինակ, հաշվելու համար թե տրված ֆունկցիան քանի անգամ է կանչվել։\n\nrm(list = ls())\ni &lt;- 0\n\nMean &lt;- function(x,...){\n  i &lt;&lt;- i + 1\n  mean(x,...)\n}\n  \nMean(1:10)\n\n[1] 5.5\n\nMean(seq(0, 1, 0.1))\n\n[1] 0.5\n\nMean(c(4, -5, 12, -6))\n\n[1] 1.25\n\ni\n\n[1] 3\n\n\n\nՔանի որ -ում տեղի ունի ստատիկ կցում, ապա “&lt;&lt;-” վերագրումը ֆունկցիայի ներսում կատարելիս այն կփոխի ոչ թե ֆունկցիայի կանչման միջավայրում փոփոխականի արժեքը, այլ ֆունկցիայի սահմանման միջավայրում։ Տե՛ս հետևյալ օրինակը՝\n\n\nrm(list = ls())\nchange &lt;- function() {x &lt;&lt;- 12; print(\"The function `change` is executed\")}\n\nx &lt;- 10\nf &lt;- function(){\n  x &lt;- 5\n  change()\n  x\n}\n\nf()\n\n[1] \"The function `change` is executed\"\n\n\n[1] 5\n\nx\n\n[1] 12\n\n\nՓոխարենը՝\n\nrm(list = ls())\nx &lt;- 10\nf &lt;- function(){\n  x &lt;- 5\n  change &lt;- function() {x &lt;&lt;- 12; print(\"The function `change` is executed\")}\n  change()\n  x\n}\n\nf()\n\n[1] \"The function `change` is executed\"\n\n\n[1] 12\n\nx\n\n[1] 10\n\n\n\n\n2.5.11 Խնդիրներ\n\nԳրել ֆունկցիա, որը որպես արգումենտներ ստանում է երկու ուղղանկյունաձև տվյալային կառուցվածք, որոնցից առաջինը պարունակում է չափումներ, իսկ երկրորդը՝ այդ չափումների համար նախատեսված նորմալության միջակայքերը։ Պետք է ստուգել, թե առաջին ուղղանկյուն տվյալներում յուրաքանչյուր չափում գտնվու՞մ է իր նորմալության միջակայքում, դրանից վերև, թե՞ ներքև և ստեղծել այդ արդյունքները պարունակող սյուներ։ Որպես առաջին ուղղանկյուն կառուցվածք կարող ենք դիտարկել airquality ուղղանկյուն կառուցվածքը, իսկ երկրորդի օրինակ կարող է լինել՝\n\n\nNR &lt;- data.frame(Variable = c(\"Wind\", \"Temp\"), Low = c(7, 70), High = c(10, 80))\nNR\n\n  Variable Low High\n1     Wind   7   10\n2     Temp  70   80\n\n\nԼուծում\n\nAdd_Col &lt;- function(dat, NR){\n  x &lt;- NR[,\"Variable\"]\n  for(i in x){\n    dat[, paste0(i,\"FL\")] &lt;- ifelse(dat[, i] &lt; NR[NR$Variable == i, \"Low\"], \"Below\",\n                                 ifelse(dat[, i] &lt;= NR[NR$Variable == i, \"High\"],\n                                        \"Normal\", \"High\"))\n  }\n  dat\n}\n\n\nhead(Add_Col(airquality,NR))\n\n  Ozone Solar.R Wind Temp Month Day WindFL TempFL\n1    41     190  7.4   67     5   1 Normal  Below\n2    36     118  8.0   72     5   2 Normal Normal\n3    12     149 12.6   74     5   3   High Normal\n4    18     313 11.5   62     5   4   High  Below\n5    NA      NA 14.3   56     5   5   High  Below\n6    28      NA 14.9   66     5   6   High  Below\n\ntable(Add_Col(airquality,NR)$WindFL)\n\n\n Below   High Normal \n    33     72     48 \n\ntable(Add_Col(airquality,NR)$TempFL)\n\n\n Below   High Normal \n    32     68     53 \n\ntable(Add_Col(airquality,NR)$WindFL, Add_Col(airquality,NR)$TempFL)\n\n        \n         Below High Normal\n  Below      0   22     11\n  High      22   20     30\n  Normal    10   26     12\n\n\nԿարող ենք նորմալության միջակայքեր պարունակող մեկ այլ ուղղանկյուն տվյալներ վերցնել՝\n\nNR2 &lt;- data.frame(Variable = c(\"Temp\", \"Ozone\" ,\"Wind\"), Low = c(70, 50, 7), \n                  High = c(80, 60, 10))\nNR2\n\n  Variable Low High\n1     Temp  70   80\n2    Ozone  50   60\n3     Wind   7   10\n\n\nԿիրառելով նույն ֆունկցիան, կստանանք՝\n\nhead(Add_Col(airquality, NR2))\n\n  Ozone Solar.R Wind Temp Month Day TempFL OzoneFL WindFL\n1    41     190  7.4   67     5   1  Below   Below Normal\n2    36     118  8.0   72     5   2 Normal   Below Normal\n3    12     149 12.6   74     5   3 Normal   Below   High\n4    18     313 11.5   62     5   4  Below   Below   High\n5    NA      NA 14.3   56     5   5  Below    &lt;NA&gt;   High\n6    28      NA 14.9   66     5   6  Below   Below   High\n\ntable(Add_Col(airquality, NR2)$WindFL)\n\n\n Below   High Normal \n    33     72     48 \n\ntable(Add_Col(airquality, NR2)$TempFL)\n\n\n Below   High Normal \n    32     68     53 \n\ntable(Add_Col(airquality, NR2)$OzoneFL)\n\n\n Below   High Normal \n    81     31      4 \n\n\n\n\n2.5.12 Ամփոփում\n\nArguments\nAnonymous functions\nLazy Evaluation\nSymbol Binding\nEnvironments, Global Environment, Parent Environment\nStatic or Lexical Scoping, Dynamic Scoping\nParent Frame\nFunction Closure\nDebugging\nConditional Execution\nMessage, Warning, Error\n\nFunctions\n\nargs()\nsearch()\nenvironment()\nget()\noptimize()\nmessage(); warning(); stop()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R ծրագրավորման միջավայր</span>"
    ]
  },
  {
    "objectID": "data.html",
    "href": "data.html",
    "title": "3  Կիրառական տվյալագիտություն",
    "section": "",
    "text": "3.1 Տվյալագիտությունը որպես նոր գիտություն\nՀիմնված է Donoho (2017) հոդվածի վրա։",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Կիրառական տվյալագիտություն</span>"
    ]
  },
  {
    "objectID": "data.html#տվյալագիտությունը-որպես-նոր-գիտություն",
    "href": "data.html#տվյալագիտությունը-որպես-նոր-գիտություն",
    "title": "3  Կիրառական տվյալագիտություն",
    "section": "",
    "text": "3.1.1 Նոր գիտության առաջացումը\nԼայնորեն տարածում գտած ժամանակակից տվյալագիտություն(Data Science) առարկան իր սկիզբն է առնում 1962 թ․-ին Ջոն Թուկիի (John Tukey) հոդվածով (Tukey 1962), որտեղ նա կոչ էր անում ռեֆորմի ենթարկել համալսարանական վիճակագրությունը և մատնանշում էր նոր գիտության առաջացումը, որի ուսումնասիրության առարկան տվյալներից սովորելն է, այսինքն՝ տվյալների վերլուծությունը։ «Տվյալագիտություն» եզրույթը ավելի ուշ է ներմուծվել Բիլլ Քլիվլենդի (Bill Clevelend) կողմից (Cleveland 2001): Տվյալագիտության առաջացումը որպես գիտություն, որը զբաղվում է տվյալների հավաքագրմամբ և վերլուծմամբ, ստեղծում է բնական հարց՝ թե ինչո՞վ է այն տարբերվում վիճակագրությունից, հատկապես կիրառական վիճակագրությունից։ Կիրառական վիճակագրությունը իր ստեղծման օրերից զբաղվել է նման հարցերով և նոր գիտության առաջացման իմաստն անորոշ է։ Այս նորաստեղծ գիտությունը հաճախ ներկայացվում է որպես վիճակագրության և մեքենայական ուսուցման միավորում, որտեղ վերջինն իր հետ բերում է նաև մեծ տվյալների հետ աշխատելու գործիքակազմ։ Նման սահմանումը չի արտահայտում այն մտավոր նորարարությունը, որն ընկած է այս նոր գիտության հիմքում։ Քանզի գիտությունն առհասարակ արագորեն վերածվում է տվյալների, որոնք կարելի է վերլուծել, տվյալագիտության նորամուծությունը ոչ միայն մեծածավալ տվյալների հետ է կապված, այլև գիտության մեջ տվյալների վերլուծության գիտական ուսումնասիրությունների (scientific studies) առաջացմամբ։ Հետևաբար տվյալագիտության մեջ ցանկացած մեթոդական նորամուծություն իր ազդեցությունն է ունենալու առհասարակ գիտության զարգացման վրա։ Այսպիսով՝ տվյալագիտության առաջացումը նպաստել է փաստերի վրա հիմնված (evidence-based) գիտության առաջացմանը։\nԻնքը Թուկին իր ելակետային հոդվածում այսպես է ընդգծում տվյալագիտության և կիրառական վիճակագրության տարբերությունը. տվյալագիտությունը նոր գիտություն է, ոչ թե մաթեմատիկայի նոր ճյուղ։ Գիտություն համարվելու համար երեք բաղադրիչների առկայությունն է պարտադիր.\n\nինտելեկտուալ բովանդակությունը,\nհասկանալի կառուցվածքը,\nարդյունքների վերջնական հաստատումը տեղի է ունենում փորձի հիման վրա: Ըստ այս սահմանման՝ մաթեմատիկան գիտություն չէ, քանի որ նրանում վերջնական հաստատման չափանիշը տրամաբանական ամբողջականության և ապացուցելիության համաձայնեցված տեսակն է: Տվյալագիտությունը բավարարում է այս երեք պայմաններին, հետևաբար այն գիտություն է, որը բնորոշվում է ոչ թե հատուկ ուսումնասիրության առարկայով, այլ ամենուրեք առկա խնդիրներով։\n\nԹուկին նաև առանձնացրել է չորս ուժ, որոնք առաջ են մղում նոր գիտությանը՝\n\nվիճակագրական տեսությունները,\nարագացող զարգացումները համակարգիչներում և ցուցադրող սարքերում,\nտարբեր ոլորտներում առկա անընդհատ աճող տվյալների զանգվածը,\nավելի ու ավելի շատ բնագավառներում քանակական արդյունքների վրա շեշտադրումը։\n\nԿարևոր է նկատել, որ այս հատկանիշների թվարկումից երևում է, որ վիճակագրությունը մասամբ է ներառված տվյալագիտությունում։\n\n\n3.1.2 Տվյալագիտության կարևոր առանձնահատկությունները\n\n3.1.2.1 Հաշվողական ծրագրային միջավայրեր՝ Quantitative programming environments\nՎերջին 50 տարիների ընթացքում տվյալների վերլուծության համար ստեղծվել են բավականաչափ հաշվողական ծրագրային միջավայրեր։ Համալսարանական վիճակագրությունում գերիշխող դիրք ունի  լեզուն։ Այն սկրիպտային (script) լեզու է, որտեղ գործողությունները կատարվում են տող առ տող՝ ճշգրտորեն համապատասխանելով հաշվողական քայլերի հերթականությանը: -ի կատարած հեղափոխության կարևորագույն առանձնահատկություններից է տեքստային ծրագրերի (code) տարածումը համացանցում և դրանց վերաօգտագործումը այլ օգտատերերի կողմից։ Այս գործընթացը հեշտացվում է նաև վերը նշված առանձնահատկության պատճառով, այն է՝ քայլերի աստիճանական կատարման շնորհիվ, հետևաբար փոխելով այլ օգտատերի տեքստային ծրագրի մեկ կամ մի քանի տողը հնարավոր է այն հարմարեցնել ձեր նպատակներին։ Այսպիսով՝ հնարավոր է անընդհատ բարելավել խնդիրների ծրագրային լուծումը, ձևավորել տեքստային ծրագրերում որոշակի գիտելիք և տվյալների վերլուծության ծրագրային կիրառելիությունը դնել գիտական հիմքերի վրա։\n\n\n3.1.2.2 Կանխատեսում և վիճակագրական եզրահանգումներ\nՀամալսարանական վիճակագրությունը կարելի է բաժանել երկու մասի՝ վիճակագրական եզրահանգումներ և կանխատեսում (Statistical inference and Prediction)։ Վիճակագրական եզրահանգումներ կատարելիս վիճակագիրները նախ փորձում են համապատասխան մոդել ընտրել, որը լավագույնս կբնութագրի գոյություն ունեցող տվյալները, ապա ընտրված մոդելի հիման վրա կատարվում են եզրահանգումներ անհայտ մեծությունների վերաբերյալ։ Սա համալսարանական վիճակագիրների գերակշռող զբաղմունքն է։ Տվյալագիտության հաջորդ կարևորագույն առանձնահատկությունը համալսարանական վիճակագրության երկրորդ և հարաբերականորեն ավելի քիչ օգտագործվող մասի՝ կանխատեսման վրա շեշտադրումն է։ Կանխատեսման խնդիրներ լուծելիս հաճախ մոդելի ընտրություն չի կատարվում, այլ փորձվում են բազմաթիվ կանխատեսման ալգորիթմներ և առաջնայնությունը տրվում է կանխատեսման լավագույն ճշգրտություն ունեցող ալգորիթմին: Կանխատեսման վրա ավելի մեծ շեշտադրումն էլ նպաստել է մեքենայական ուսուցում առարկայի առաջացմանը։\n\n\n3.1.2.3 Մեքենայական ուսուցման հիմնական պարադիգմը՝ CTF (The Common Task Framework)\nԿարդալ Section 6 - The Predictive Culture’s Secret Sauce (Donoho 2017):\n\n\n3.1.2.4 Տվյալագիտության ուսումնասիրության ամբողջ շրջանակը\nՏվյալագիտության ուսումնասիրության ամբողջ շրջանակը կարելի է բաժանել 6 մասի՝\n\nՏվյալների ուսումնասիրություն և նախապատրաստում (Data Exploration and Preparation)։ Առաջին քայլն է տվյալների հետ աշխատելիս։ Հավաքագրված տվյալները նախ պետք է ուսումնասիրվեն՝ պարզելու համար դրանց հետ կապված խնդիրները։ Օրինակ, եթե հավաքագրվել են տվյալներ մարդկանց վերաբերյալ, ապա պետք է ստուգել, որ մարդկանց սեռը ցույց տվող փոփոխականում լինեն միայն երկու հնարավոր արժեքներ, կամ մարդկանց տարիքը ցույց տվող փոփոխականում բացասական արժեքներ չլինեն։ Տվյալների սկզբնական ուսումնասիրությունից հետո սկսվում է տվյալների նախապատրաստությունը վերլուծության համար` ներառյալ տվյալների մաքրում, խմբավորում կամ բաժանում՝ հետագա դրանք վերլուծության հարմարեցման նպատակով։\nՏվյալների ներկայացում և ձևափոխում (Data Representation and Transformation)։ Այս փուլը հիմնականում ընդգրկում է տվյալների տեղաբաշխումը տարբեր ձևաչափերով ու զանազան կառուցվածքներով։ Գոյություն ունեն տվյալների բաշխման ինչպես համընդհանուր սկզբունքներ և տեսություններ, օրինակ՝ հարաբերական տվյալների բազաներ (Relational databases), ինչպես նաև տվյալների ստացման ոլորտից կախված առանձնահատկություններ (օրինակ՝ պատկերային տվյալներ կամ համացանցից քաղված տեքստային տվյալներ)։ Տվյալագետը կատարում է կառուցվածքային վերափոխումներ՝ սկզբնական տվյալները դարձնելով ավելի բացահայտող տեսքի։\nՀաշվարկներ տվյալների հետ (Computing with Data)։ Տվյալագետը հաճախ ստիպված է լինում իրականացնել բարդ հաշվարկներ պարունակող հսկայածավալ նախագծեր, ուստի հաշվողական արդյունավետության հարցերը պետք է լինեն ուշադրության կենտրոնում։\nՏվյալների մոդելավորում (Data Modeling)։ Վիճակագրական եզրահանգումներում կատարվում է հավանականային մոդելի ընտրություն, իսկ կանխատեսման կամ՝ մեքենայական ուսուցման մեջ՝ կանխատեսման ալգորիթմի ընտրություն։\nՏվյալների պատկերում և ներկայացում (Data Visualization and Presentation)։ Պարզագույն դեպքում սա տվյալների պատկերային ներակայացումն է գոյություն ունեցող գծապատկերների տեսակների միջոցով (օրինակ՝ սյունապատկերներ), սակայն հաճախ պետք է կատարել ոճային փոփոխություններ խնդրի առանձնահատկություններից կախված (օրինակ՝ գունավորում) կամ ստեղծել նոր մեթոդներ և գծապատկերների նոր տեսակներ։\nԳիտություն տվյալագիտության վերաբերյալ (Science about Data Science)։ Վերոնշյալ փուլերը կատարելիս և լուծումների առանձնահատկությունները գիտակցելիս պետք է հիշել, որ տվյալագիտությունը գիտություն է և մոտեցումները համընդհանուր են՝ անկախ տվյալների առաջացման ոլորտից։ Հետևաբար վերը նշված փուլերի վերաբերյալ գիտելիքները պետք է վեր հանվեն, քննարկվեն և փոխանցվեն՝ վերաօգտագործման ու հետագա զարգացման համար։\n\n\n\n\n3.1.3 Եզրափակում\nՏվյալների վերլուծության կարևորության աճին զուգահեռ ծրագրավորողները փորձ են արել այդ ճյուղն առանձնացնել վիճակագրությունից։ Մեքենայական ուսուցման առաջացումն էլ երբեմն հակադրվել է դասական, համալսարանական վիճակագրությանը։ Վերը նշվածը ցույց է տալիս ինչպես նման հակադրության անհրաժեշտության բացակայությունը, այնպես էլ տվյալագիտության լիակատար ինքնուրույնությունը՝ վիճակագրությունից և հաշվողական ծրագրավորումից։",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Կիրառական տվյալագիտություն</span>"
    ]
  },
  {
    "objectID": "data.html#sac",
    "href": "data.html#sac",
    "title": "3  Կիրառական տվյալագիտություն",
    "section": "3.2 Split - Apply - Combine",
    "text": "3.2 Split - Apply - Combine\nԱյս բաժնում ուսումնասիրելու ենք շրջապտույտի ֆունկցիաները (Loop Functions), որոնք օգտագործվում են կիրառելու համար «բաժանել-կիրառել-միավորել» (Split-Apply-Combine) մարտավարությունը: Մարտավարության նպատակն է բաժանել տվյալները ավելի փոքր մասերի, կիրառել տրված ֆունկցիան մասերի վրա և միավորել ստացված արդյունքները։ Ստորև նկարում բերված աղյուսակն ամփոփ ներկայացնում է շրջապտույտի ֆունկցիաները։ Ձախ կողմի տողերը ցույց են տալիս օբյեկտի տեսակը, որը փոխանցվում է ֆունկցիային, իսկ սյուները՝ ֆունկցիայի կողմից վերադարձվող օբյեկտի տեսակը։ Գունավորված ֆունկցիաները -ում նախասահմանված ֆունկցիաներն են, իսկ սպիտակները՝ Հադլի Ուիքհեմի (Hadley Wickham) ստեղծված plyr գրադարանից (Wickham 2011)։\n\n\n\nApply\n\n\n\n3.2.1 lapply(), sapply()\nԵնթադրենք ունենք ցուցակ, որի մեջ գրված են երեք մատրից, և ուզում ենք հաշվել դրանցից յուրաքանչյուրի որոշիչը։\n\nl &lt;- list(M1 = matrix(c(2, 1, 3, 3), nrow = 2), \n          M2 = matrix(c(12, 31, 44, 2), nrow = 2), \n          M3 = matrix(c(18, 87, 0, -2), nrow = 2))\n\ndet() ֆունկցիային կարելի է որպես արգումենտ տալ միայն մատրից։ Որպեսզի կարողանանք այն կիրառել ցուցակի բոլոր ենթամատրիցների վրա, անհրաժեշտ է շրջապտույտի հրամանով հերթով դուրս հանել ցուցակի բոլոր ենթամատրիցները։\n\ndeter &lt;- c()\n\nfor(x in l){\n  deter &lt;- c(deter, det(x))\n}\n\ndeter\n\n[1]     3 -1340   -36\n\n\nԱյս ամբողջն ավելի հեշտ կլիներ, եթե կարողանայինք -ին ուղղորդել, որպեսզի այն կիրառեր նույն ցուցակի բոլոր ենթամատրիցների համար։ Հենց դրա համար օգտագործում ենք lapply() ֆունկցիան, որն ունի երեք արգումենտ. նախ պետք է տալ ցուցակը, ապա՝ կիրառվող ֆունկցիան, և բազմակետ արգումենտում կարելի է նշել բոլոր այն արգումենտները, որոնք ուզում ենք փոխանցել կիրառվող ֆունկցիային։ lapply() ֆունկցիան միշտ վերադարձնում է ցուցակ։\n\nlapply(l, det)\n\n$M1\n[1] 3\n\n$M2\n[1] -1340\n\n$M3\n[1] -36\n\n\nԻնչպես երևում է, մատրիցների անունները պահպանվել են, և յուրաքանչյուրի համար հաշվվել է դրա որոշիչը։\nԱյժմ ենթադրենք ունենք ցուցակ, որում գրված են երեք վեկտոր, և անհրաժեշտ է հաշվել յուրաքանչյուրի միջին թվաբանականը։\n\nl &lt;- list(a = c(12, 33, 44, 55), b = c(56, -16, NA), \n          c = c(85, 654, -567, -10))\nlapply(l, mean)\n\n$a\n[1] 36\n\n$b\n[1] NA\n\n$c\n[1] 40.5\n\n\nԵրկրորդ վեկտորի միջին թվաբանականը NA է, քանի որ այդ վեկտորը պարունակում է NA արժեք։ Ինչպես գիտենք, mean() ֆունկցիան ունի արգումենտ, որի միջոցով հնարավոր է վեկտորից դուրս հանել NA արժեքները՝ մինչ միջինի հաշվարկը։ Բազմակետ արգումենտի միջոցով mean() ֆունկցիայի այս արգումենտը կարող ենք փոխանցել lapply()-ին։\n\nlapply(l, mean, na.rm=TRUE)\n\n$a\n[1] 36\n\n$b\n[1] 20\n\n$c\n[1] 40.5\n\n\nlapply() ֆունցկիան, որպես արգումենտ, ընդունում է ֆունկցիա, հետևաբար, ինչպես նմանատիպ այլ դեպքերում, հնարավոր է որպես արգումենտ փոխանցել անանուն ֆունկցիա։ Դիտարկենք մատրիցներ պարունակող նախկին ցուցակը և փորձենք դուրս հանել այդ մատրիցներից յուրաքանչյուրի առաջին տողը։\n\nl &lt;- list(M1 = matrix(c(2, 1, 3, 3), nrow = 2), \n          M2 = matrix(c(12, 31, 44, 2), nrow = 2),\n          M3 = matrix(c(18, 87, 0, -2), nrow = 2))\nl\n\n$M1\n     [,1] [,2]\n[1,]    2    3\n[2,]    1    3\n\n$M2\n     [,1] [,2]\n[1,]   12   44\n[2,]   31    2\n\n$M3\n     [,1] [,2]\n[1,]   18    0\n[2,]   87   -2\n\nlapply(l, function(x) x[1,])\n\n$M1\n[1] 2 3\n\n$M2\n[1] 12 44\n\n$M3\n[1] 18  0\n\n\nsapply() ֆունկցիան կատարում է նույն գործողությունները, ինչ lapply()-ը, պարզապես հնարավորության դեպքում վերադարձվող ցուցակը պարզեցվում է (s = simplify) և վերադարձվում է համասեռ վեկտոր (երբ վերադարձվող ցուցակի յուրաքանչյուր տարր մեկ երկարությամբ համասեռ վեկտոր է), մատրից (եթե վերադարձվող ցուցակի յուրաքանչյուր տարր մեկից մեծ և մյուսներին հավասար երկարությամբ համասեռ վեկտոր է), իսկ երբ հնարավոր չէ պարզեցնել, վերադարձվում է ցուցակ։\n\nl &lt;- list(M1 = matrix(c(2, 1, 3, 3), nrow = 2), \n          M2 = matrix(c(12, 31, 44, 2), nrow = 2),\n          M3 = matrix(c(18, 87, 0, -2), nrow = 2))\nsapply(l, det)\n\n   M1    M2    M3 \n    3 -1340   -36 \n\nl &lt;- list(a = c(12, 33, 44, 55), b = c(56, -16, NA), \n          c = c(85, 654, -567, -10))\nsapply(l, mean, na.rm = TRUE)\n\n   a    b    c \n36.0 20.0 40.5 \n\nl &lt;- list(M1 = matrix(c(2, 1, 3, 3), nrow = 2), \n          M2 = matrix(c(12, 31, 44, 2), nrow = 2), \n          M3 = matrix(c(18, 87, 0, -2), nrow = 2))\nsapply(l, function(x) x[1,])\n\n     M1 M2 M3\n[1,]  2 12 18\n[2,]  3 44  0\n\n\n\n\n3.2.2 apply()\napply() ֆունկցիան կիրառվում է զանգվածների, այդ թվում՝ մատրիցների վրա։ Առաջին արգումենտը զանգվածն է, որի վրա ուզում ենք ֆունկցիա կիրառել, երկրորդը՝ չափողականությունը (margin), որն օգտագործվելու է զանգվածի հետ աշխատելիս, իսկ երրորդը՝ կիրառվող ֆունկցիան։ Բազմակետ արգումենտը ևս առկա է։ Օրինակ.\n\nM &lt;- matrix(1:20, ncol = 4)\nM\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    6   11   16\n[2,]    2    7   12   17\n[3,]    3    8   13   18\n[4,]    4    9   14   19\n[5,]    5   10   15   20\n\n\nՏողերն առաջին չափողականությունն են, սյուները՝ երկրորդ, և կարող ենք հաշվել միջինները.\n\napply(M, 1, mean)\n\n[1]  8.5  9.5 10.5 11.5 12.5\n\napply(M, 2, mean)\n\n[1]  3  8 13 18\n\n\nԱյս օգտագործումն այնքան հաճախ է, որ գոյություն ունեն առանձին արագացված ֆունկցիաներ՝\n\nrowSums(x) = apply(x, 1, sum)\nrowMeans(x) = apply(x, 1, mean)\ncolSums(x) = apply(x, 2, sum)\ncolMeans(x) = apply(x, 2, mean)\n\nԲացի ավելի կարճ գրառում ունենալուց, այս ֆունկցիաները շատ ավելի արագ կիրագործեն հաշվարկը, քան apply()-ով նույնն անելը։ Եթե կիրառվելու են այլ ֆունցկիաներ, կարող ենք փոխանցել դրանց արգումենտները ևս՝\n\napply(x, 1, quantile, probs = c(0.25, 0.75))\n\n    [,1]  [,2]\n25%  4.5 20.25\n75% 13.5 64.75\n\n\nՏեսնում ենք, որ արդյունքները միավորվել են և ներկայացվում են մատրիցի տեսքով։\n\n\n3.2.3 mapply()\nՆախորդ ֆունկցիաները տրված օբյեկտի ենթաօբյեկտները հաջորդաբար փոխանցում էին ֆունկցիային՝ որպես արգումենտ։ Այժմ ենթադրենք ունենք մի քանի օբյեկտ, որոնց ենթաօբյեկտները հաջորդաբար փոխանցվում են տրված ֆունկցիայի տարբեր արգումենտներին։ Ֆունկցիաների միաժամանակյա կանչումը տարբեր փոփոխականներին արժեքներ տալով կատարվում է mapply() ֆունկցիայի միջոցով։ Օրինակ՝\n\nM &lt;- airquality[, 1:4]\nmapply(FUN = quantile, M, \n       c(0.1, 0.25,0.5,0.75), na.rm = T)\n\n  Ozone.10% Solar.R.25%    Wind.50%    Temp.75% \n      11.00      115.75        9.70       85.00 \n\n\nmapply()-ի առաջին արգումենտը կիրառվող ֆունկցիան է, երկրորդը՝ արգումենտը, որը պետք է փոպանցել այդ ֆունկցիային, և այլն։ Բացի այդ, կիրառվող ֆունկցիայի ևս մեկ արգումենտի լռելյայն արժեքը փոխվել է՝ na.rm = T:\n\n\n3.2.4 vapply(), tapply()\nvapply() կատարում է նույն գործառույթը, ինչ sapply(), տարբերությամբ, որ sapply() փորձելով պարզեցնում է արդյունքը, իսկ vapply() թույլ է տալիս օգտագործողին նախապես նշել վերադարձվող արդյունքի տեսակը։ Եթե նշված տեսակով հնարավոր չէ ներկայացնել արդյունքները, տեղի է ունենում սխալ։ Սա թույլ է տալիս խոսափել անակնկալ ներկայացումներից, որոնք հետագայում կարող են սխալ արդյունքի բերել։\n\nvapply(X = airquality, \n       FUN = class, \n       FUN.VALUE = character(1))\n\n    Ozone   Solar.R      Wind      Temp     Month       Day \n\"integer\" \"integer\" \"numeric\" \"integer\" \"integer\" \"integer\" \n\n\nՀաջորդը՝ tapply, հենց իրագործում է «բաժանել-կիրառել-միավորել» մարտավարությունը։ Ենթադրենք պետք է տվյալները բաժանել մասերի, կիրառել մասերի վրա տրված ֆունկցիան և միավորել ստացված արդյունքները։ Ֆունկցիան կոչվում է tapply(), որտեղ t նշանակում է table: Դիտարկենք նախասահմանված UCBAdmissions ուղղանկյունաձև տվյալները, որը պարունակում է Բերկլիի համալսարանի վեց ամենամեծ դեպարտամենտներում ընդունված ուսանողների քանակները 1973 թվականին։\n\nUCBAdmissions &lt;- as.data.frame(UCBAdmissions)\ndim(UCBAdmissions)\n\n[1] 24  4\n\nhead(UCBAdmissions)\n\n     Admit Gender Dept Freq\n1 Admitted   Male    A  512\n2 Rejected   Male    A  313\n3 Admitted Female    A   89\n4 Rejected Female    A   19\n5 Admitted   Male    B  353\n6 Rejected   Male    B  207\n\n\nՀաշվենք ընդունված բոլոր ուսանողների մեջ աղջիկների և տղաների քանակները՝\n\ntapply(X = UCBAdmissions$Freq, \n       INDEX = UCBAdmissions$Gender, \n       FUN = sum)\n\n  Male Female \n  2691   1835 \n\n\nԿարելի է անգամ խմբավորել երկու փոփոխականով՝\n\ntapply(X = UCBAdmissions$Freq,\n       INDEX = list(UCBAdmissions$Gender,UCBAdmissions$Admit), \n       FUN = sum)\n\n       Admitted Rejected\nMale       1198     1493\nFemale      557     1278\n\n\nՍա տալիս է յուրաքանչյուր սեռի ընդուված և չընդունված ուսանողների ընդհանուր քանակը։\n\n\n3.2.5 Վեկտորացում՝ Vectorize()\n լեզվի ուժեղ կողմերից է վեկտորական գործողությունների առկայությունը: Թվաբանական գործողություններ կատարելիս, ինչպես նաև շատ այլ ֆունկցիաներ կիրառելիս, հնարավոր է որպես արգումենտ փոխանցել համասեռ վեկտոր, և այդ դեպքում ֆունկցիան իր գործողությունները կկատարի կոորդինատ առ կոորդինատ։ Այդպիսի ֆունկցիաները կոչվում են վեկտորացված ֆունկցիաներ։ Օրինակ՝\n\nx &lt;- seq(0,10)\nsqrt(x)\n\n [1] 0.000000 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751\n [9] 2.828427 3.000000 3.162278\n\n\nԿան նաև ֆունկցիաներ, որոնք վեկտորացված չեն։ -ում կա Vectorize ֆունկցիա, որը որպես արգումենտ փոխանցված ֆունկցիան կարող է «վեկտորացնել» և վերադարձնել դրա վեկտորացված տարբերակը։ Մինչ այդ, դիտարկենք ոչ վեկտորացված ֆունկցիայի օրինակ.\n\\[f(x)=\\left\\{\\begin{matrix}\n&x,\\,x&lt;0\\\\\n&x^2,\\,x\\geq 0\n\\end{matrix}\\right.\n\\]\nԱյս ֆունկցիայի՝ ստորև բերված գծապատկերը ստանալու համար անհրաժեշտ է ստանալ դրա արժեքները \\(x=[-1,1]\\) հատվածի կետերում՝\n\n\n\n\n\n\n\n\n\nՍահմանենք վերը բերված ֆունկցիան -ում։\n\nf &lt;- function(x){\n  if(x &lt; 0)\n    y &lt;- x\n  else\n    y &lt;- x^2\n  return(y)\n}\n\nԱյս ֆունկցիայի դեպքում, որովհետև if-ը պահանջում է մեկ երկարությամբ տրամաբանական պայման, վեկտոր փոխանցելուց կստացվի սխալ՝\n\nx &lt;- -5:5\ntry(f(x))\n\nError in if (x &lt; 0) y &lt;- x else y &lt;- x^2 : the condition has length &gt; 1\n\n\nԱնհրաժեշտ արդյունքը ստանալու երեք տարբերակ՝\n\nOգտագործել apply ընտանիքի ֆունկցիաներից որևէ մեկը՝\n\n\nsapply(x, f)\n\n [1] -5 -4 -3 -2 -1  0  1  4  9 16 25\n\n\n\nԱյնպես վերասահմանել ֆունկցիան, որ այն վեկտորացված լինի՝\n\n\nf_ &lt;- function(x) ifelse(x &lt; 0, x, x^2)\nf_(x)\n\n [1] -5 -4 -3 -2 -1  0  1  4  9 16 25\n\n\n\nԿիրառել Vectorize() ֆունկցիան՝ տրված ֆունկցիան վեկտորացնելու համար՝\n\n\nf0 &lt;- Vectorize(f, \"x\")\nf0(x)\n\n [1] -5 -4 -3 -2 -1  0  1  4  9 16 25\n\n\n\n\n3.2.6 Աղյուսակներ՝ tables\n-ում աղյուսակները ներկայացվում են որպես հատուկ տեսակի տվյալներ՝ table օբյեկտներ։ Աղյուսակները ստեղծվում են table() ֆունկցիայի միջոցով՝ որպես արգումենտ փոխանցելով վեկտոր կամ ֆակտոր։ Օրինակ՝\n\nx &lt;- table(airquality$Month)\nx\n\n\n 5  6  7  8  9 \n31 30 31 31 30 \n\n\n\n\n3.2.7 split()\nsplit() ֆունկցիան բաժանում է տրված օբյեկտը մասերի՝ օգտագործելով որպես երկրորդ արգումենտ տրված ֆակտորը կամ ֆակտորների ցուցակը։ split()-ը միշտ վերադարձնում ՝ ցուցակ, հետևաբար արդյունքը կարող ենք փոխանցել sapply() կամ lapply() ֆունկցիաներին։ split()-ի և lapply()-ի միաժամանակյա կիրառումը կտա նույն արդյունքը, ինչ tapply()-ի կիրառումը, տարբերությամբ, որ tapply()-ն տրոհում է վեկտորը (և, հետևաբար, որպես արգումենտ փոխանցվող ֆունկցիան կարող է կիրառվել միայն վեկտորի վրա), իսկ split()-ը կարող է տրոհել ոչ միայն վեկտոր, ուստի split()-ից ստացված ենթաօբյեկտների վրա կարող ենք կիրառել ֆունկցիաներ, որոնք աշխատում են նաև ոչ-վեկտորների վրա։ Oրինակ՝ airquality տվյալներով, հաշվել Ozone, Solar.R, Wind և Temp միջին արժեքները ըստ ամսիների՝\n\nsapply(X = split(x = airquality[, c(\"Ozone\", \"Solar.R\", \"Wind\", \"Temp\")], f = airquality$Month),\n       FUN = colMeans, na.rm = TRUE)\n\n                5         6          7          8         9\nOzone    23.61538  29.44444  59.115385  59.961538  31.44828\nSolar.R 181.29630 190.16667 216.483871 171.857143 167.43333\nWind     11.62258  10.26667   8.941935   8.793548  10.18000\nTemp     65.54839  79.10000  83.903226  83.967742  76.90000\n\n\nԿարելի է փոխանցել նաև ֆակտորների ցուցակ՝ բազմակի խմբավորման համար։ Ստեղծենք նոր փոփոխական՝ զույգ/կենտ օր.\n\ndat &lt;- airquality\ndat$Day_Type &lt;- ifelse(dat$Day %% 2 == 0, \"Even\", \"Odd\")\n\nsapply(X = split(x = dat[, c(\"Ozone\", \"Solar.R\", \"Wind\", \"Temp\")], f = list(dat$Month, dat$Day_Type)), FUN = colMeans, na.rm = TRUE)\n\n           5.Even     6.Even     7.Even     8.Even     9.Even     5.Odd\nOzone    26.38462  23.250000  58.250000  51.928571  29.800000  20.84615\nSolar.R 187.42857 196.800000 234.933333 161.769231 158.333333 174.69231\nWind     11.88000   9.633333   9.353333   9.426667   9.933333  11.38125\nTemp     65.73333  79.600000  84.466667  84.200000  77.066667  65.37500\n           6.Odd     7.Odd     8.Odd     9.Odd\nOzone    34.4000  59.85714  69.33333  33.21429\nSolar.R 183.5333 199.18750 180.60000 176.53333\nWind     10.9000   8.55625   8.20000  10.42667\nTemp     78.6000  83.37500  83.75000  76.73333\n\n\nԵթե լիներ պիտակների համադրություն, որին համապատասխան արժեք չլիներ, ապա drop արգումենտով հնարավոր այդ համադրությունը դուրս գցել վերջնական արդյունքը ներկայացնելիս։\n\n\n3.2.8 aggregate(), xtabs()\n\n\n3.2.9 Խնդիրներ\n\nՏրված ուղղանկյունաձև տվյալների համար պարզել յուրաքանչյուր սյան տեսակը։\n\nԼուծում\n\nairquality &lt;- airquality[1:10,]\nclass(airquality)\n\n[1] \"data.frame\"\n\n\nԵթե կիրառենեք class() ֆունկցիան, կստանանք ուղղանկյունաձև կառուցվածքի տեսակը։ Փոխարենը պետք է class() ֆունկցիան կիրառել ուղղանկյունաձև տվյալների սյուների վրա՝ sapply() ֆունկցիայի միջոցով։ Պարզելու համար թե ինչպես sapply() ֆունկցիան կաշխատի, տրված ուղղանկյունաձև տվյալները վերածենք ցուցակի՝\n\nas.list(airquality)\n\n$Ozone\n [1] 41 36 12 18 NA 28 23 19  8 NA\n\n$Solar.R\n [1] 190 118 149 313  NA  NA 299  99  19 194\n\n$Wind\n [1]  7.4  8.0 12.6 11.5 14.3 14.9  8.6 13.8 20.1  8.6\n\n$Temp\n [1] 67 72 74 62 56 66 65 59 61 69\n\n$Month\n [1] 5 5 5 5 5 5 5 5 5 5\n\n$Day\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nԱյսպես՝ sapply() ֆունկցիան կկիրառվի սյուն առ սյուն՝\n\nsapply(airquality, class)\n\n    Ozone   Solar.R      Wind      Temp     Month       Day \n\"integer\" \"integer\" \"numeric\" \"integer\" \"integer\" \"integer\" \n\n\nԿարելի է օգտագործել նաև apply(), նշելով, որ այն պետք է կիրառվի սյուների վրա.\n\napply(X = airquality, MARGIN = 2,\n      FUN = class)\n\n    Ozone   Solar.R      Wind      Temp     Month       Day \n\"numeric\" \"numeric\" \"numeric\" \"numeric\" \"numeric\" \"numeric\" \n\n\n\nՏրված է ցուցակ, որը պարունակում է վեկտորներ։ Պարզել յուրաքանչյուր վեկտորի երկարությունը։\n\nԼուծում\n\nl &lt;- list(x = c(11, 0.98, -0.32, 43), \n          y = c(\"a\", \"cda\", \"12\"),\n          z = \"c\")\nl\n\n$x\n[1] 11.00  0.98 -0.32 43.00\n\n$y\n[1] \"a\"   \"cda\" \"12\" \n\n$z\n[1] \"c\"\n\n\nԵթե կիրառենք length() ֆունկցիան, ապա կստանանք ցուցակի երկարությունը, ոչ թե ցուցակի յուրաքանչյուր ենթաօբյեկտի երկարությունը։\n\nlength(l)\n\n[1] 3\n\n\nՓոխարենը՝\n\nsapply(l, length)\n\nx y z \n4 3 1 \n\n\n\nairquality տվյալներում հաշվել յուրաքանչյուր ամսվա միջին ջերմաստիճանը, ըստ ամիսների, ապա ապա Ozone-ի միջինը ըստ ամիսների՝ հիշելով, որ վերջինը պարունակում է NA անհայտ արժեքներ։\n\nԼուծում\n\ntapply(X = airquality$Temp,\n       INDEX = airquality$Month,\n       FUN = mean)\n\n   5 \n65.1 \n\ntapply(X = airquality$Ozone,\n       INDEX = airquality$Month,\n       FUN = mean, na.rm = TRUE)\n\n     5 \n23.125 \n\n\nԿամ էլ՝\n\nsapply(split(x = airquality[, c(\"Temp\", \"Ozone\")], \n             f = airquality$Month, drop = TRUE),\n       FUN = function(x) colMeans(x, na.rm = TRUE))\n\n           5\nTemp  65.100\nOzone 23.125\n\n\n\nՍահմանել ֆունկցիա, որը վերադարձնում է տրված թվային փոփոխականի նմազագույնը, միջինը, կիսորդիչը, միջին քառակուսային շեղումը և առավելագույնը՝ համասեռ վեկտորի տեսքով։ Կիրառել այդ ֆունկցիան airquality-ի Ozone փոփոխականի վրա՝ ըստ ամիսների։\n\nԼուծում\n\nStat &lt;- function(x, ...){\n  y &lt;- c(min(x, ...), mean(x,...),\n         median(x, ...), sd(x,...), \n         median(x, ...))\n  names(y) &lt;- c(\"Min\", \"Mean\", \"Median\", \"Sd\", \"Median\")\n  y\n}\n\ntapply(X = airquality$Ozone,\n       INDEX = airquality$Month,\n       FUN = Stat, na.rm = TRUE)\n\n$`5`\n    Min    Mean  Median      Sd  Median \n 8.0000 23.1250 21.0000 11.3696 21.0000 \n\n\n\nԷրատոսթենեսի մաղի հետևյալ իրագործումը գրել առանց շրջապտույտի՝\n\n\nrm(list = ls())\nn &lt;- 100\nY &lt;- seq_len(n)\nY &lt;- Y[Y &gt; 1]\nfor(x in Y){\n  Y &lt;- Y[Y %% x != 0 | Y == x]\n}\n\nԼուծում\nՕգտագործելու ենք ֆունկցիա, որն աշխատեցնելիս գլոբալ միջավայրում սահմանված համասեռ վեկտորից հեռացվում են պարզ թվերը։\n\nn &lt;- 100\nX &lt;- seq_len(n)\n\nSieve &lt;- function(x){\n if(x != 1){\n   X &lt;&lt;- X[ X %% x != 0 | X == x]\n } \n  else X &lt;&lt;- X[ X &gt; 1]\n}\n\nl &lt;- lapply(1:n, Sieve)\nX\n\n [1]  2  3  5  7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97\n\nidentical(X, Y)\n\n[1] TRUE\n\n\n\nՎերասահմանել ստորև բերված ֆունկցիան օգտվելով &lt;&lt;- վերագրման գործողությունից, այնպես որ ֆունկցիայի սահմանման մեջ այլևս for կառուցվածք չլինի։\n\n\nrm(list = ls())\n\nAdd_Col &lt;- function(dat, NR){\n  x &lt;- NR[, \"Variable\"]\n  for(i in x){\n    dat[, paste0(i, \"FL\")] &lt;- ifelse(dat[, i] &lt; NR[NR$Variable == i, \"Low\"], \"Below\", ifelse(dat[, i] &lt;= NR[NR$Variable == i, \"High\"], \"Normal\", \"High\"))\n  }\n  dat\n}\n\nԼուծում\nՄարտավարությունը՝ for-ը փոխարինել մեկ արգումենտանոց ֆունկցիայով և կիրառել այդ ֆունկցիան կրկնման փոփոխականի տիրույթի վրա apply ընտանիքի որևէ ֆունկցիայով։\n\ndat &lt;- airquality\nNR &lt;- data.frame(Variable = c(\"Wind\", \"Temp\"), \n                 Low = c(7, 70), High = c(10, 80))\n\nx &lt;- as.character(NR[, \"Variable\"])\n\nAdd_Col2 &lt;- function(i){\n \n    dat[, paste0(i,\"FL\")] &lt;&lt;- ifelse(dat[, i] &lt; NR[NR$Variable == i, \"Low\"], \"Below\",\n                                     ifelse(dat[, i] &lt;= NR[NR$Variable == i, \"High\"], \"Normal\", \"High\"))\n}\n\ns &lt;- sapply(x, Add_Col2)\n\nԻնչպես տեսնում ենք՝ ուղղանկյուն տվյալները որպես արգումենտ չենք փոխանցում մեր սահմանած ֆունկցիային, քանի որ վերջինս հնարավորություն ունի ոչ միայն ստանալու գլոբալ միջավայրից արժեքներ, այլև փոփոխություններ կատարել գլոբալ միջավայրում։\nՍտորև բերված վերագրման նպատակը գործողությունների կատարման ընթացքը թաքցնելն է։ Մենք չունենք այդ փոփոխականի կարիքը։\n\ns &lt;- sapply(x, Add_Col2)\n\nԻրականում նոր ուղղանկյուն տվյալ չի ստեղծվել, այլ գոյություն ունեցողի վրա կատարվել են անհրաժեշտ փոփոխությունները։\n\nhead(dat)\n\n  Ozone Solar.R Wind Temp Month Day WindFL TempFL\n1    41     190  7.4   67     5   1 Normal  Below\n2    36     118  8.0   72     5   2 Normal Normal\n3    12     149 12.6   74     5   3   High Normal\n4    18     313 11.5   62     5   4   High  Below\n5    NA      NA 14.3   56     5   5   High  Below\n6    28      NA 14.9   66     5   6   High  Below\n\ntable(dat$WindFL)\n\n\n Below   High Normal \n    33     72     48 \n\ntable(dat$TempFL)\n\n\n Below   High Normal \n    32     68     53 \n\ntable(dat$WindFL, dat$TempFL)\n\n        \n         Below High Normal\n  Below      0   22     11\n  High      22   20     30\n  Normal    10   26     12\n\n\n\nairquality-ում Ջերմաստիճանը նորմալ է, եթե այն գտնվում է \\([68,86]\\) միջակայքում։ Եթե ցածր է՝ համարվում է ցուրտ, եթե բարձր է՝ տաք։ Հաշվել Ջերմաստիճանի յուրաքանչյուր դասակարգման համար Ozone-ի լայնքի միջնակետը (լայնքի միջնակետը նվազագույն և առավելագույն արժեքների միջին թվաբանականն է)։ Օգտագործել անանուն ֆունկցիա։\n\nԱյնուհետև նույնը՝ ըստ ամիսների և ամիսների ներսում՝ ըստ Temp դասակարգման։\nԼուծում\n\ndat &lt;- airquality\ndat$Temp.C &lt;- ifelse(dat$Temp &lt; 68, \"Cold\", ifelse(dat$Temp &lt;= 86, \"Normal\", \"Hot\"))\ntapply(X = dat$Ozone, INDEX = dat$Temp.C, FUN = function(x, ...) mean(range(x, ...)), na.rm = T)\n\n  Cold    Hot Normal \n  21.0   80.5   87.5 \n\n\n\ntapply(X = dat$Ozone, INDEX = list(dat$Month, dat$Temp.C), \n       FUN = function(x,...) mean(range(x, ...)), na.rm = T, drop = T)\n\n  Cold  Hot Normal\n5 21.0   NA   58.0\n6 10.5 36.0   19.0\n7   NA 49.0   68.0\n8   NA 61.5   84.5\n9  9.5 48.5   23.5\n\n\n\nԳրել անանուն ֆունկցիա, որն ունի մեկ արգումենտ՝ համասեռ վեկտոր։ Եթե այդ վեկտորը թվային չէ, ոչինչ չի վերադարձնում։ Եթե թվային է, վերադարձնում է երկրորդ ամենափոքր արժեքը։ Կիրառել այդ ֆունկցիան airquality-ի սյուների վրա։\n\nԼուծում\n\napply(X = airquality, MARGIN = 2, FUN = function(x) if(is.numeric(x)) return(sort(x)[2]))\n\n  Ozone Solar.R    Wind    Temp   Month     Day \n    4.0     8.0     2.3    57.0     5.0     1.0 \n\n\n\n\n3.2.10 Ամփոփում\n\nLoop Functions/ Functions\nSplit - Apply - Combine\n\n\n- lapply(); sapply()\n- apply()\n- rowSums(); rowMeans(); colSums(); colMeans()\n- vapply(); mapply(); tapply()\n- Vectorize()\n- split()\n- aggregate(); xtabs()\n\n\n\n\n\nCleveland, William S. 2001. “Data Science: An Action Plan for Expanding the Technical Areas of the Field of Statistics.” International Statistical Review 69 (1): 21–26.\n\n\nDonoho, David. 2017. “50 Years of Data Science.” Journal of Computational and Graphical Statistics 26 (4): 745–66.\n\n\nTukey, John W. 1962. “The Future of Data Analysis.” In Breakthroughs in Statistics: Methodology and Distribution, 408–52. Springer.\n\n\nWickham, Hadley. 2011. “The Split-Apply-Combine Strategy for Data Analysis.” Journal of Statistical Software 40 (1): 1–29. https://www.jstatsoft.org/v40/i01/.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Կիրառական տվյալագիտություն</span>"
    ]
  },
  {
    "objectID": "intro.html#հիմնական-գրադարանները-base-packages",
    "href": "intro.html#հիմնական-գրադարանները-base-packages",
    "title": "1  Ներածություն",
    "section": "1.4 Հիմնական գրադարանները (Base packages)",
    "text": "1.4 Հիմնական գրադարանները (Base packages)\n միջավայրը կարելի է ներբեռնել Համապարփակ Պահոցային Ցանցից, որը հայտնի է իր անգլերեն CRAN (Comprehensive R Archive Network) հապավմամբ և հասանելի է հետևյալ հասցեով՝ CRAN։ Լեզուն ունի բազմաթիվ գրադարաններ (packages)՝ գրված աշխարհի տարբեր անկյուններում ապրող ծրագրավորողների կողմից։ Ցանկացած ոք իրավունք ունի ստեղծելու նոր գրադարան և այն տեղադրելու կենտրոնական գրադարան CRAN-ում, այդպիսով այն հասանելի դարձնելով լեզվի բոլոր օգտագործողներին։ Որպեսզի օգտագործողի ստեղծած գրադարանը հնարավոր լինի տեղադրել կենտրոնական գրադարանում, այն պետք է որոշակի ստանդարտների բավարարի, օրինակ ունենա համապատասխան օգտագործման ուղեցույց (package documentation)։\n լեզվի հիմնական տեղադրման մեջ ներառված են մի շարք գրադարաններ, որոնք կոչվում են հիմնական գրադարաններ (base packages)։ Դրանք են՝ base (հիմնական ֆունկցիաներ), stats (վիճակագրական ֆունկցիաներ), utils (օգտակար ֆունկցիաներ), graphics (գծագրերի ֆունկցիաներ), grDevices (գծագրերի սարքեր), methods (մեթոդներ) և datasets (տվյալային աղյուսակներ)։",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Ներածություն</span>"
    ]
  },
  {
    "objectID": "stat.html",
    "href": "stat.html",
    "title": "4  Կիրառական վիճակագրություն",
    "section": "",
    "text": "4.1 Հավանականային բաշխումներ",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Կիրառական վիճակագրություն</span>"
    ]
  },
  {
    "objectID": "stat.html#ներածություն",
    "href": "stat.html#ներածություն",
    "title": "4  Կիրառական վիճակագրություն",
    "section": "",
    "text": "4.1.1 Սկզբնական վիճակագրական գաղափարներ\n\n\n4.1.2 Հիմնական գծապատկերների տեսակները\n\n\n4.1.3 Բանաձևեր\n\n\n4.1.4 Նախասահմանված վիճակագրական գրադարան stats\nԻնչպես նշել ենք նախկինում՝ base::search() ֆունկցիան կարող է կանչվել պարզելու թե որ նախասահմանված (կամ օգտագործողի կողմից) կանչված գրադարաններն են կցված տվյալ պահին։\n\nsearch()\n\n[1] \".GlobalEnv\"        \"package:stats\"     \"package:graphics\" \n[4] \"package:grDevices\" \"package:utils\"     \"package:datasets\" \n[7] \"package:methods\"   \"Autoloads\"         \"package:base\"     \n\n\nԻնչպես տեսնում ենք ստորև՝ stats գրադարանը կանչված է։ Այն նախասահմանված գրադարան է -ում։\n\nlength(ls(\"package:stats\"))\n\n[1] 454\n\nls(\"package:stats\")[1:20]\n\n [1] \"acf\"                  \"acf2AR\"               \"add.scope\"           \n [4] \"add1\"                 \"addmargins\"           \"aggregate\"           \n [7] \"aggregate.data.frame\" \"aggregate.ts\"         \"AIC\"                 \n[10] \"alias\"                \"anova\"                \"ansari.test\"         \n[13] \"aov\"                  \"approx\"               \"approxfun\"           \n[16] \"ar\"                   \"ar.burg\"              \"ar.mle\"              \n[19] \"ar.ols\"               \"ar.yw\"               \n\n\nԱյս գրադարանի հետ մեկտեղ կօգտագործենք նաև գծապատկերների համար նախատեսված graphics գրադարանը։\n\nls(\"package:graphics\")[1:20]\n\n [1] \"abline\"          \"arrows\"          \"assocplot\"       \"axis\"           \n [5] \"Axis\"            \"axis.Date\"       \"axis.POSIXct\"    \"axTicks\"        \n [9] \"barplot\"         \"barplot.default\" \"box\"             \"boxplot\"        \n[13] \"boxplot.default\" \"boxplot.matrix\"  \"bxp\"             \"cdplot\"         \n[17] \"clip\"            \"close.screen\"    \"co.intervals\"    \"contour\"        \n\n\n\n\n4.1.5 Խնդիրներ\n\n\n4.1.6 Ամփոփում",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Կիրառական վիճակագրություն</span>"
    ]
  },
  {
    "objectID": "stat.html#նկարագրողական-և-հետազոտական-վիճակագրություն",
    "href": "stat.html#նկարագրողական-և-հետազոտական-վիճակագրություն",
    "title": "4  Կիրառական վիճակագրություն",
    "section": "4.2 Նկարագրողական և հետազոտական վիճակագրություն",
    "text": "4.2 Նկարագրողական և հետազոտական վիճակագրություն\n\n4.2.1 Հիմնական վիճականիներ\n\n\n4.2.2 Հետազոտություն\n\n\n4.2.3 Ամփոփում\n\nDescriptive statistics\n\n\nmean()\nmedian()\nsd()\nvar()\nquantile()\nsummary()\nboxplot()\nhist()\nboxplot.stats()\n\n\nPlots\n\n\nplot()\nabline()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Կիրառական վիճակագրություն</span>"
    ]
  },
  {
    "objectID": "stat.html#գնահատականների-տեսություն",
    "href": "stat.html#գնահատականների-տեսություն",
    "title": "4  Կիրառական վիճակագրություն",
    "section": "4.3 Գնահատականների տեսություն",
    "text": "4.3 Գնահատականների տեսություն\n\n4.3.1 Առավելագույն ճշմարտանմանության գնահատական\n\n\n4.3.2 Մոմենտների մեթոդ\n\n\n4.3.3 Մեկ-քայլ առավելագույն ճշմարտանմանության գնահատական",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Կիրառական վիճակագրություն</span>"
    ]
  },
  {
    "objectID": "stat.html#վարկածների-ստուգում",
    "href": "stat.html#վարկածների-ստուգում",
    "title": "4  Կիրառական վիճակագրություն",
    "section": "4.4 Վարկածների ստուգում",
    "text": "4.4 Վարկածների ստուգում",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Կիրառական վիճակագրություն</span>"
    ]
  },
  {
    "objectID": "stat.html#գծային-ռեգրեսիա",
    "href": "stat.html#գծային-ռեգրեսիա",
    "title": "4  Կիրառական վիճակագրություն",
    "section": "4.5 Գծային ռեգրեսիա",
    "text": "4.5 Գծային ռեգրեսիա\n\n4.5.1 Ամփոփում\n\nDescriptive statistics\n\n\nmean()\nmedian()\nsd()\nvar()\nquantile()\nsummary()\nboxplot()\nhist()\nboxplot.stats()\n\n\nPlots\n\n\nplot()\nabline()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Կիրառական վիճակագրություն</span>"
    ]
  },
  {
    "objectID": "rintro.html#շարան-գործողություն-the-pipe-operator",
    "href": "rintro.html#շարան-գործողություն-the-pipe-operator",
    "title": "2  R ծրագրավորման միջավայր",
    "section": "2.6 Շարան գործողություն (the pipe operator)",
    "text": "2.6 Շարան գործողություն (the pipe operator)\n\n2.6.1 Նախաբան\nԱնգլերենում pipe բառը ունի մի քանի իմաստ։ Առաջնային իմաստը, որից էլ |&gt; գործողությունը ստացել է իր անունը, առաջացել է to pipe բայից, որի նշանակություններից մեկն է դասավորել, դարսել, շարան դնել (գործողությունները հերթագայվում են հատ առ հատ)։ Քանի որ անգլերենում այդ բառը և՛ բայ է, և՛ գոյական, երկար (մոտ 20 րոպե) մտածելուց հետո որոշեցինք բառը թարգմանել «շարան», որպեսզի բնական կերպով առաջանա նաև «շարանել» բայը։ Թեև սա փոխանցում է գործողության հաշվողական իմաստը, այնուամենայնիվ, երբ օպերատորը ներմուծվեց -ում Ստեֆան Միլթոն Բեյչի (Stefan Milton Bache) կողմից (Bache and Wickham 2025), այն միաժամանակ խաղում էր բայի/գոյականի այլ իմաստի՝ «ծխամորճ»-ի վրա կատարված բառախաղով և հղում էր անում նկարիչ Ռենե Մագրիտի «Պատկերների դավաճանությունը» («Սա ծխամորճ չէ») աշխատանքին. հենց այդ նկարն էլ օգտագործվել էր նրա կողմից ստեղծված, շարան գործողությունը սահմանող magrittr գրադարանի կազմի նկարում։ Դժվար կլիներ գտնել ավելի հարմար անուն այս օպերատորի համար, որը կփոխանցեր նաև ծխամորճի հետ առընչությունը։\nՇարան օպերատորը -ում ներմուծվել է 4.1.0 (մայիսի 18, 2021թ.) թողարկման մեջ։ 4.2.0 (ապրիլի 22, 2022թ.) և 4.3.0 (ապրիլի 21, 2023թ.) թողարկումների մեջ շարանի լրացուցիչ գործառույթներ ավելացվեցին։\n\n\n2.6.2 Սահմանումը և կիրառությունները\nՇարան օպերատորը թույալտրում է շարանել օբյեկտը ընդառաջ փոխանցելով (ձախից աջ) այն ֆունկցիայի կանչին՝ թույլատրելով արտահայտել օբյեկտը ձևափոխող գործողությունների հաջորդականություն։ Շարանը շարահյուսական գործառույթ ունի և հեշտացնում է քայլերի հերթագայումը։ Հետևյալ շարանումը x |&gt; f(y) վերլուծվում է որպես x |&gt; f(x, y): Այսինքն՝ ձախ կողմի արժեքը փոխանցվում է որպես աջ կողմի ֆունկցիայի առաջին փոփոխականի արժեք։ Օգտագործման պարզագույն ձևը հետևյալ երկու համարծեք գործողությունների օրինակն է՝\n\nsum(1, 2)\n\n[1] 3\n\n1 |&gt; sum(2)\n\n[1] 3\n\n\nԱմենաօգտակար կիառությունը, սակայն, պարզ է դառնում ուղղանյունաձև տվյալների հետ աշխատելիս։ Դիտարկենք հետևյալ օրինակը՝\n\nmtcars |&gt; head()\n\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\nmtcars |&gt; head(n = 1)\n\n          mpg cyl disp  hp drat   wt  qsec vs am gear carb\nMazda RX4  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n\n\nԵրկրորդ օրնակում աջ կողմի ֆունցկիան օգտագործում է հավելյալ փոփոխականներ՝ ֆունկցիաիյ կանչն ավելի հատկանշական դարձնելու համար։\nԲերենք ավելի բարդ օրինակ։ Ենթադրենք mtcars տվյալներում պետք է հաշվել միջին mpg-ն՝ ըստ cyl-երի։ Առանց շարանելու դա կարող է իրականացվել որպես՝\n\nsapply(split(mtcars$mpg, mtcars$cyl), mean)\n\n       4        6        8 \n26.66364 19.74286 15.10000 \n\n\nԹեև այս ծրագրային գրառումն ընդամենը մեկ տող է, բայց այն ներառում է մի քանի հաջորդական գործողություններ, որոնք շարանմամբ ավելի պարզ տեսք կստանան։\n\nmtcars$mpg |&gt; split(mtcars$cyl) |&gt; sapply(mean)\n\n       4        6        8 \n26.66364 19.74286 15.10000 \n\n\nԿամ էլ ավելի կարճ՝\n\nmtcars |&gt; with(tapply(mpg, cyl, mean))\n\n       4        6        8 \n26.66364 19.74286 15.10000 \n\n\nԱյժմ ենթադրենք, որ փախ կողմից փոխանցվող արժեքը պետք է ոչ թե աջ կողմի ֆունցկիայի առաջին փոփոխականի արժեք դառնա, այլ՝ մեկ ուրիշ։ Դիտարկենք հետևյալ ֆունկցիան, որը երեք փոփոխական ունի և ստեղծում է տրված անունով նոր սյուն՝ ուղղանկյուն տվյալների համար։\n\nAdd_Col &lt;- function(col_name, values, dat){\n  dat[, col_name] &lt;- values\n  dat\n}\n\nԱյժմ կարող ենք օգտագործել շարան օպերատորը՝ ստեղծելու նոր սյուն mtcars տվյալներում: Ստորև գրված ծրագիրը չի աշխատի, քանզի ուղղանկյուն տվյալները փոխանցվում են ֆունկցիայի առաջին փոփոխականին, որը որպես արժեք ուղղանկյուն տվյալնեե չի կարող ընդունել։\n\nmtcars |&gt; Add_Col(\"new_mpg\", mtcars$mpg * 2) |&gt; head()\n\nՓոխարենը կարող ենք օգտագործել _ գործողությունը՝ տեղորոշման համար։\n\nmtcars |&gt; Add_Col(\"new_mpg\", mtcars$mpg * 2, dat = _) |&gt; head()\n\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb new_mpg\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4    42.0\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4    42.0\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1    45.6\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1    42.8\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2    37.4\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1    36.2\n\n\nԿամ էլ՝ կարելի է պարզապես նշել բոլոր փոփոխականների անունները՝ բաց թողնելով միայն այն, որը պետք է արժեք ստանա ձախ կողմից։\n\nmtcars |&gt; Add_Col(col_name = \"new_mpg\", values = mtcars$mpg * 2) |&gt; head()\n\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb new_mpg\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4    42.0\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4    42.0\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1    45.6\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1    42.8\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2    37.4\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1    36.2",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R ծրագրավորման միջավայր</span>"
    ]
  },
  {
    "objectID": "rintro.html#օբյեկտ-կողմնորոշված-ծրագրավորում",
    "href": "rintro.html#օբյեկտ-կողմնորոշված-ծրագրավորում",
    "title": "2  R ծրագրավորման միջավայր",
    "section": "2.7 Օբյեկտ կողմնորոշված ծրագրավորում",
    "text": "2.7 Օբյեկտ կողմնորոշված ծրագրավորում\n\n2.7.1 S3 դաս\n\n\n\n\nBache, Stefan Milton, and Hadley Wickham. 2025. Magrittr: A Forward-Pipe Operator for r. https://doi.org/10.32614/CRAN.package.magrittr.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R ծրագրավորման միջավայր</span>"
    ]
  },
  {
    "objectID": "rintro.html#s3-դաս",
    "href": "rintro.html#s3-դաս",
    "title": "2  R ծրագրավորման միջավայր",
    "section": "2.8 S3 դաս",
    "text": "2.8 S3 դաս\n\n\n\n\nBache, Stefan Milton, and Hadley Wickham. 2025. Magrittr: A Forward-Pipe Operator for r. https://doi.org/10.32614/CRAN.package.magrittr.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R ծրագրավորման միջավայր</span>"
    ]
  },
  {
    "objectID": "stat.html#սկզբնական-վիճակագրական-գաղափարներ",
    "href": "stat.html#սկզբնական-վիճակագրական-գաղափարներ",
    "title": "4  Կիրառական վիճակագրություն",
    "section": "4.2 Սկզբնական վիճակագրական գաղափարներ",
    "text": "4.2 Սկզբնական վիճակագրական գաղափարներ\n\n4.2.1 Նկարագրողական վիճակագրություն\n\n\n4.2.2 Հիմնական գծապատկերների տեսակները\n\n\n4.2.3 Բանաձևեր\n\n\n4.2.4 Նախասահմանված վիճակագրական գրադարան stats\nԻնչպես նշել ենք նախկինում՝ base::search() ֆունկցիան կարող է կանչվել պարզելու թե որ նախասահմանված (կամ օգտագործողի կողմից) կանչված գրադարաններն են կցված տվյալ պահին։\n\nsearch()\n\n[1] \".GlobalEnv\"        \"package:stats\"     \"package:graphics\" \n[4] \"package:grDevices\" \"package:utils\"     \"package:datasets\" \n[7] \"package:methods\"   \"Autoloads\"         \"package:base\"     \n\n\nԻնչպես տեսնում ենք ստորև՝ stats գրադարանը կանչված է։ Այն նախասահմանված գրադարան է -ում։\n\nlength(ls(\"package:stats\"))\n\n[1] 454\n\nls(\"package:stats\")[1:20]\n\n [1] \"acf\"                  \"acf2AR\"               \"add.scope\"           \n [4] \"add1\"                 \"addmargins\"           \"aggregate\"           \n [7] \"aggregate.data.frame\" \"aggregate.ts\"         \"AIC\"                 \n[10] \"alias\"                \"anova\"                \"ansari.test\"         \n[13] \"aov\"                  \"approx\"               \"approxfun\"           \n[16] \"ar\"                   \"ar.burg\"              \"ar.mle\"              \n[19] \"ar.ols\"               \"ar.yw\"               \n\n\nԱյս գրադարանի հետ մեկտեղ կօգտագործենք նաև գծապատկերների համար նախատեսված graphics գրադարանը։\n\nls(\"package:graphics\")[1:20]\n\n [1] \"abline\"          \"arrows\"          \"assocplot\"       \"axis\"           \n [5] \"Axis\"            \"axis.Date\"       \"axis.POSIXct\"    \"axTicks\"        \n [9] \"barplot\"         \"barplot.default\" \"box\"             \"boxplot\"        \n[13] \"boxplot.default\" \"boxplot.matrix\"  \"bxp\"             \"cdplot\"         \n[17] \"clip\"            \"close.screen\"    \"co.intervals\"    \"contour\"        \n\n\n\n\n4.2.5 Խնդիրներ\n\n\n4.2.6 Ամփոփում",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Կիրառական վիճակագրություն</span>"
    ]
  },
  {
    "objectID": "stat.html#հավանականային-բաշխումներ",
    "href": "stat.html#հավանականային-բաշխումներ",
    "title": "4  Կիրառական վիճակագրություն",
    "section": "",
    "text": "4.1.1 Դիսկրետ հավասարաչափ բաշխում",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Կիրառական վիճակագրություն</span>"
    ]
  }
]